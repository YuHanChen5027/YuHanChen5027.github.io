<!DOCTYPE html>
<html lang="zh">

<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="google-site-verification" content="xBT4GhYoi5qRD5tr338pgPM5OWHHIDR6mNg1a3euekI" />
    <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover">
    <meta name="description" content="关于Android开发| 这里是 陈宇瀚 的个人博客，一个有梦想还没秃的Android程序员。">
    <meta name="keywords"  content="陈宇瀚, ChenYuhan, Android, 陈宇瀚的博客, Java ">
    <meta name="theme-color" content="#000000">
    
    <!-- Open Graph -->
    <meta property="og:title" content="JAVA数据结构内部及基础方法实现一（Map） - 陈宇瀚的博客 | ChenYuHan Blog">
    
    <meta property="og:type" content="article">
    <meta property="og:description" content="JAVA有几种常用的数据结构，主要是继承Collection和Map这两个主要接口的数据实现类
">
    
    <meta property="article:published_time" content="2020-12-20T19:50:02Z">
    
    
    <meta property="article:author" content="陈宇瀚">
    
    
    <meta property="article:tag" content="JAVA">
    
    <meta property="article:tag" content="数据结构">
    
    
    <meta property="og:image" content="https://yuhanchen5027.github.io//img/avatar-cyh.png">
    <meta property="og:url" content="https://yuhanchen5027.github.io//article/2020/12/20/JAVA%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%86%85%E9%83%A8%E5%8F%8A%E5%9F%BA%E7%A1%80%E6%96%B9%E6%B3%95%E5%AE%9E%E7%8E%B0%E4%B8%80-Map/">
    <meta property="og:site_name" content="陈宇瀚的博客 | ChenYuHan Blog">
    
    <title>JAVA数据结构内部及基础方法实现一（Map） - 陈宇瀚的博客 | ChenYuHan Blog</title>

    <!-- Web App Manifest -->
    <link rel="manifest" href="/pwa/manifest.json">

    <!-- Favicon -->
    <link rel="shortcut icon" href="/img/favicon.ico">
    
    <!-- Canonical URL -->
    <link rel="canonical" href="https://yuhanchen5027.github.io//article/2020/12/20/JAVA%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%86%85%E9%83%A8%E5%8F%8A%E5%9F%BA%E7%A1%80%E6%96%B9%E6%B3%95%E5%AE%9E%E7%8E%B0%E4%B8%80-Map/">

    <!-- Bootstrap Core CSS -->
    <link rel="stylesheet" href="/css/bootstrap.min.css">

    <!-- Custom CSS -->
    <link rel="stylesheet" href="/css/hux-blog.min.css">

    <!-- Custom Fonts -->
    <!-- <link href="http://maxcdn.bootstrapcdn.com/font-awesome/4.3.0/css/font-awesome.min.css" rel="stylesheet" type="text/css"> -->
    <!-- Hux change font-awesome CDN to qiniu -->
    <link href="//cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css">


    <!-- HTML5 Shim and Respond.js IE8 support of HTML5 elements and media queries -->
    <!-- WARNING: Respond.js doesn't work if you view the page via file:// -->
    <!--[if lt IE 9]>
        <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
        <script src="https://oss.maxcdn.com/libs/respond.js/1.4.2/respond.min.js"></script>
    <![endif]-->

    <!-- ga & ba script hoook -->
    <script></script>
</head>


<!-- hack iOS CSS :active style -->
<body ontouchstart="">

    <!-- Navigation -->

    <nav class="navbar navbar-default navbar-custom navbar-fixed-top">
        
        <div class="container-fluid">
            <!-- Brand and toggle get grouped for better mobile display -->
            <div class="navbar-header page-scroll">
                <button type="button" class="navbar-toggle">
                    <span class="sr-only">Toggle navigation</span>
                    <span class="icon-bar"></span>
                    <span class="icon-bar"></span>
                    <span class="icon-bar"></span>
                </button>
                <a class="navbar-brand" href="/">ChenYuHan Blog</a>
            </div>

            <!-- Collect the nav links, forms, and other content for toggling -->
            <div id="huxblog_navbar">
                <div class="navbar-collapse">
                    <ul class="nav navbar-nav navbar-right">
                        <li>
                            <a href="/">Home</a>
                        </li>
                        
                        
                        
                        
                        <li>
                            <a href="/about/">About</a>
                        </li>
                        
                        
                        
                        <li>
                            <a href="/archive/">Archive</a>
                        </li>
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        <li class="search-icon">
                            <a href="javascript:void(0)">
                                <i class="fa fa-search"></i>
                            </a>
                        </li>
                    </ul>
                </div>
            </div>
            <!-- /.navbar-collapse -->
        </div>
        <!-- /.container -->
    </nav>

    <script>
        // Drop Bootstarp low-performance Navbar
        // Use customize navbar with high-quality material design animation
        // in high-perf jank-free CSS3 implementation
        var $body = document.body;
        var $toggle = document.querySelector('.navbar-toggle');
        var $navbar = document.querySelector('#huxblog_navbar');
        var $collapse = document.querySelector('.navbar-collapse');

        var __HuxNav__ = {
            close: function () {
                $navbar.className = " ";
                // wait until animation end.
                setTimeout(function () {
                    // prevent frequently toggle
                    if ($navbar.className.indexOf('in') < 0) {
                        $collapse.style.height = "0px"
                    }
                }, 400)
            },
            open: function () {
                $collapse.style.height = "auto"
                $navbar.className += " in";
            }
        }

        // Bind Event
        $toggle.addEventListener('click', function (e) {
            if ($navbar.className.indexOf('in') > 0) {
                __HuxNav__.close()
            } else {
                __HuxNav__.open()
            }
        })

        /**
         * Since Fastclick is used to delegate 'touchstart' globally
         * to hack 300ms delay in iOS by performing a fake 'click',
         * Using 'e.stopPropagation' to stop 'touchstart' event from 
         * $toggle/$collapse will break global delegation.
         * 
         * Instead, we use a 'e.target' filter to prevent handler
         * added to document close HuxNav.  
         *
         * Also, we use 'click' instead of 'touchstart' as compromise
         */
        document.addEventListener('click', function (e) {
            if (e.target == $toggle) return;
            if (e.target.className == 'icon-bar') return;
            __HuxNav__.close();
        })
    </script>
    <!-- Search -->
<div class="search-page">
  <div class="search-icon-close-container">
    <span class="search-icon-close">
      <i class="fa fa-chevron-down"></i>
    </span>
  </div>
  <div class="search-main container">
    <div class="row">
      <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
        <form></form>
        <input type="text" id="search-input" placeholder="$ grep...">
        </form>
        <div id="search-results" class="mini-post-list"></div>
      </div>
    </div>
  </div>
</div>

    <!-- Image to hack wechat -->
<!-- <img src="/img/icon_wechat.png" width="0" height="0"> -->
<!-- <img src="/img/home-bg.jpg" width="0" height="0"> -->

<!-- Post Header -->



<style type="text/css">
    header.intro-header{
        position: relative;
        background-image: url('/img/home-bg.jpg');
        background: ;
    }

    
</style>

<header class="intro-header" >

    <div class="header-mask"></div>
    
    <div class="container">
        <div class="row">
            <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
                <div class="post-heading">
                    <div class="tags">
                        
                        <a class="tag" href="/archive/?tag=JAVA" title="JAVA">JAVA</a>
                        
                        <a class="tag" href="/archive/?tag=%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84" title="数据结构">数据结构</a>
                        
                    </div>
                    <h1>JAVA数据结构内部及基础方法实现一（Map）</h1>
                    
                    <h2 class="subheading"></h2>
                    <span class="meta">Posted by 陈宇瀚 on December 20, 2020</span>
                </div>
            </div>
        </div>
    </div>
</header>






<!-- Post Content -->
<article>
    <div class="container">
        <div class="row">

    <!-- Post Container -->
            <div class="
                col-lg-8 col-lg-offset-2
                col-md-10 col-md-offset-1
                post-container">

                <!-- Multi-Lingual -->
                

				<p>JAVA有几种常用的数据结构，主要是继承<strong>Collection</strong>和<strong>Map</strong>这两个主要接口的数据实现类</p>

<p>在jdk1.7和jdk1.8中，实现会有些许不同，之后会在注解中添加两版本区别
下面分别介绍几个常用的数据结构(按照继承的接口分为两类)，以下代码截取自<strong>基于JAVA8的android SDK 28</strong></p>
<h1 id="map">Map</h1>
<p><strong>Map</strong>接口提供<strong>key</strong>到<strong>value</strong>的映射。一个<strong>Map</strong>中不能包含相同的<strong>key</strong>，每个<strong>key</strong>只能映射一个<strong>value</strong>。<strong>Map</strong>接口提供3种集合的视图，<strong>Map</strong>的内容可以被当作一组<strong>key</strong>集合，一组<strong>value</strong>集合，或者一组<strong>key-value</strong>映射。</p>

<h2 id="hashmap以下源码基于java8与java7有较大差别">HashMap(以下源码基于JAVA8，与JAVA7有较大差别)</h2>
<p><strong>HashMap</strong>继承<strong>Map</strong>接口，实现一个key-value映射的哈希表。是非同步的，同时允许n<strong>ull value</strong>和<strong>null key</strong>。
<strong>HashMap</strong>的父类接口，以及内部有几个主要的变量，如下：</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
</pre></td><td class="rouge-code"><pre>public class HashMap&lt;K,V&gt; extends AbstractMap&lt;K,V&gt;
    implements Map&lt;K,V&gt;, Cloneable, Serializable 

//默认的初始容量-必须是2的幂。
static final int DEFAULT_INITIAL_CAPACITY = 1 &lt;&lt; 4; // aka 16
//最大容量，如果两个带参数的构造函数中的任何一个隐式指定了更高的值，则使用该值。一定是2的幂&lt;= 1&lt;&lt;30。
static final int MAXIMUM_CAPACITY = 1 &lt;&lt; 30;
//未设置负载系统时默认的负载系数/加载因子。
static final float DEFAULT_LOAD_FACTOR = 0.75f;
//容器计数阈值,当table对应hash位置的链表元素数量超过这个阈值，该位置的链表会转换为红黑树
static final int TREEIFY_THRESHOLD = 8;
//容器计数阈值,当table对应hash位置的红黑树元素数量小雨这个阈值，该位置的红黑树会转换为单链表
static final int UNTREEIFY_THRESHOLD = 6;

static final int MIN_TREEIFY_CAPACITY = 64;
//存放数据的表，就是HashMap数据基类的数组，在第一次使用时进行初始化，并根据需要调整大小。分配时，长度总是2的幂。
transient Node&lt;K,V&gt;[] table;
//此Map映射中包含的键-值对的数量。
transient int size;
//(threshold = 容量*负载系数/加载因子)扩容阈值，可以说是一个是否需要扩容的判断条件，当HashMap的size&gt;threshold时会进行resize操作。
int threshold;
//负载系数/加载因子，可以说是当前HashMap满的程度，
//假设它等于0.75，那么在HashMap的键值对数量超过容量*0.75时，则会进行扩容。
//保证有足够的空间进行数据存放，同时不会经常进行扩容。
final float loadFactor;
</pre></td></tr></tbody></table></code></pre></div></div>
<p><strong>Node</strong>:<strong>HashMap</strong>的数据基类</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
</pre></td><td class="rouge-code"><pre>static class Node&lt;K,V&gt; implements Map.Entry&lt;K,V&gt; {
        //hash值
        final int hash;
        final K key;
        V value;
        //下一个对象
        Node&lt;K,V&gt; next;

        Node(int hash, K key, V value, Node&lt;K,V&gt; next) {
            this.hash = hash;
            this.key = key;
            this.value = value;
            this.next = next;
        }

        public final K getKey()        { return key; }
        public final V getValue()      { return value; }
        public final String toString() { return key + "=" + value; }

        public final int hashCode() {
            return Objects.hashCode(key) ^ Objects.hashCode(value);
        }

        public final V setValue(V newValue) {
            V oldValue = value;
            value = newValue;
            return oldValue;
        }

        public final boolean equals(Object o) {
            if (o == this)
                return true;
            if (o instanceof Map.Entry) {
                Map.Entry&lt;?,?&gt; e = (Map.Entry&lt;?,?&gt;)o;
                if (Objects.equals(key, e.getKey()) &amp;&amp;
                    Objects.equals(value, e.getValue()))
                    return true;
            }
            return false;
        }
    }
    
    //JAVA8引入红黑树TreeNode，之后会分析
    static final class TreeNode&lt;K,V&gt; extends LinkedHashMap.LinkedHashMapEntry&lt;K,V&gt;
</pre></td></tr></tbody></table></code></pre></div></div>
<p><strong>Node</strong>是一个单链表结构的类，由于<strong>HashMap</strong>存储健值对时，会先将<strong>key</strong>转成<strong>hash</strong>与当前容量-1进行一个与操作( (n - 1) &amp; hash)转换成一个<strong>下标值</strong>，在数组中对应一个<strong>Node</strong>，所以会存在转换出来的<strong>下标值</strong>相同(<strong>哈希冲突</strong>)，但<strong>key</strong>不同的情况，所以同一个<strong>下标值</strong>可能对应不同的健值对。所以table数组采用<strong>Node</strong>这个单链表的作为存储基类，用于存放这些<strong>下标值</strong>相同，但键值不同的数据；</p>

<p>在<strong>JAVA8</strong>中考虑到如果哈希冲突多的情况，单链表<strong>Node</strong>的长度会越来越长，此时通过单链表来寻找对应<strong>Key</strong>对应的<strong>Value</strong>的时候就会使得时间复杂度达到<strong>O(n)</strong>，因此在<strong>JAVA8</strong>中引入了<strong>TreeNode(红黑树)</strong>，当链表长度超过<strong>TREEIFY_THRESHOLD(8)</strong>的时候，会将单链表<strong>Node</strong>转换成红黑树<strong>TreeNode</strong>。</p>

<p><em>红黑树是一种易于增删改查的二叉树，他对与数据的查询的时间复杂度是O(logn)，所以利用红黑树的特点就可以更高效的对 HashMap 中的元素进行操作。</em></p>
<h4 id="构造方法">构造方法</h4>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
82
83
84
85
86
87
88
89
90
91
92
93
94
95
96
97
98
99
100
101
102
103
104
105
106
107
108
109
110
111
112
113
114
115
116
117
118
119
120
121
122
123
124
125
126
127
128
129
130
131
132
133
134
135
136
137
138
139
140
141
142
143
144
145
146
147
148
149
150
151
152
153
154
155
156
157
158
159
160
161
162
163
164
165
166
167
168
169
170
171
172
173
174
175
176
177
178
179
180
181
182
183
184
185
186
187
188
189
190
191
192
193
194
195
196
197
198
199
200
201
202
203
204
205
206
207
208
209
210
211
212
213
214
215
216
217
218
219
220
221
222
223
224
225
226
227
</pre></td><td class="rouge-code"><pre>    public HashMap() {
        this.loadFactor = DEFAULT_LOAD_FACTOR; // all other fields defaulted
    }
    //构造一个具有指定的初始容量和默认的负载系数(0.75)的空的HashMap，。
    public HashMap(int initialCapacity) {
        this(initialCapacity, DEFAULT_LOAD_FACTOR);
    }
    
    //构造一个具有指定的初始容量和负载系数的空的HashMap，
    public HashMap(int initialCapacity, float loadFactor) {
        if (initialCapacity &lt; 0)
            throw new IllegalArgumentException("Illegal initial capacity: " +
                                               initialCapacity);
        if (initialCapacity &gt; MAXIMUM_CAPACITY)
            initialCapacity = MAXIMUM_CAPACITY;
        if (loadFactor &lt;= 0 || Float.isNaN(loadFactor))
            throw new IllegalArgumentException("Illegal load factor: " +
                                               loadFactor);
        this.loadFactor = loadFactor;
        this.threshold = tableSizeFor(initialCapacity);
    }
    //构造一个与指定的Map相同键值对映射的新的HashMap。该HashMap是用默认的负载系数(0.75)创建的，初始容量足以容纳指定的Map中的映射。
    public HashMap(Map&lt;? extends K, ? extends V&gt; m) {
        this.loadFactor = DEFAULT_LOAD_FACTOR;
        putMapEntries(m, false);
    }
    
    final void putMapEntries(Map&lt;? extends K, ? extends V&gt; m, boolean evict) {
        //得到推入的map大小
        int s = m.size();
        if (s &gt; 0) {
            if (table == null) { // pre-size
                //根据map大小和负载因子计算出设置的容量大小
                float ft = ((float)s / loadFactor) + 1.0F;
                //判断容量是否超出最大容量
                int t = ((ft &lt; (float)MAXIMUM_CAPACITY) ?
                         (int)ft : MAXIMUM_CAPACITY);
                if (t &gt; threshold)
                    threshold = tableSizeFor(t);
            }
            else if (s &gt; threshold)
                resize();
            for (Map.Entry&lt;? extends K, ? extends V&gt; e : m.entrySet()) {
                K key = e.getKey();
                V value = e.getValue();
                putVal(hash(key), key, value, false, evict);
            }
        }
    }
    //tableSizeFor的功能（不考虑大于最大容量的情况）是返回大于输入参数且最近的2的整数次幂的数。比如10，则返回16。
    static final int tableSizeFor(int cap) {
        int n = cap - 1;
        n |= n &gt;&gt;&gt; 1;
        n |= n &gt;&gt;&gt; 2;
        n |= n &gt;&gt;&gt; 4;
        n |= n &gt;&gt;&gt; 8;
        n |= n &gt;&gt;&gt; 16;
        return (n &lt; 0) ? 1 : (n &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + 1;
    }
    /**********************以下两个方法对于整个HashMap极其重要**********************/
    
    //HashMap添加值的方法
    final V putVal(int hash, K key, V value, boolean onlyIfAbsent,
                   boolean evict) {
        Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; int n, i;
        //判断当前HashMap的table大小
        if ((tab = table) == null || (n = tab.length) == 0)
            //table未创建，调用resize()进行初始化(扩容)
            n = (tab = resize()).length;
            
        //去table中最后一位与hash进行按位与操作，得到的值赋值给i，
        //判断位置的值是否为null，为null则代表还没有与添加数据键值相应的hash相同的数据推入过;
        if ((p = tab[i = (n - 1) &amp; hash]) == null)
            //为空则直接将键值对添加的table的i位置
            tab[i] = newNode(hash, key, value, null);
        else {
            //若不为空，则对应键值hash位置已有数据
            //e代表最后存储的键值对
            Node&lt;K,V&gt; e; K k;
            if (p.hash == hash &amp;&amp;
                ((k = p.key) == key || (key != null &amp;&amp; key.equals(k))))
                //键值hash相同，键值内容也相同，代表将值替换
                e = p;
            else if (p instanceof TreeNode)
                //此时p对应位置的数据量超过TREEIFY_THRESHOLD(8)，Node已转换为TreeNode,所以采用TreeNode的新增节点方式
                e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(this, tab, hash, key, value);
            else {
                //此时p对应位置的数据量未超过TREEIFY_THRESHOLD(8)，所以还没转化成红黑树。仍是一个Node链表
                
                //binCount用于计算当前链表的节点数，binCount从0开始，代表binCount = 节点数+1；
                for (int binCount = 0; ; ++binCount) {
                    //判断是否到了链表的末尾节点
                    if ((e = p.next) == null) {
                        //在链表末尾添加新生成的Node
                        p.next = newNode(hash, key, value, null);
                        //判断当前节数是否超过TREEIFY_THRESHOLD(8)，超过则将链表Node转换成红黑树
                        if (binCount &gt;= TREEIFY_THRESHOLD， - 1) // -1 for 1st
                            treeifyBin(tab, hash);
                        break;
                    }
                    //判断是否存在hash相同，key值相同的键值，存在则跳出循环。
                    if (e.hash == hash &amp;&amp;
                        ((k = e.key) == key || (key != null &amp;&amp; key.equals(k))))
                        break;
                    p = e;
                }
            }
            //e!=null代表map种存在key值相同的键值，将对应的valuet替换成新的，同时返回旧value
            if (e != null) { 
                V oldValue = e.value;
                //onlyIfAbsent调用方法时传入，如果为true，则不会覆盖值
                if (!onlyIfAbsent || oldValue == null)
                    e.value = value;
                afterNodeAccess(e);//一个回调方法
                return oldValue;
            }
        }
        ++modCount;
        //判断是否需要扩容map
        if (++size &gt; threshold)
            resize();
        afterNodeInsertion(evict);//一个回调方法
        return null;
    }
    
    //HashMap的扩容方法
    final Node&lt;K,V&gt;[] resize() {
        //获得当前table
        Node&lt;K,V&gt;[] oldTab = table;
        //获取当前map容量，扩容阈值
        int oldCap = (oldTab == null) ? 0 : oldTab.length;
        int oldThr = threshold;
        int newCap, newThr = 0;
        if (oldCap &gt; 0) {
            if (oldCap &gt;= MAXIMUM_CAPACITY) {
                //当前容量超过了可设的最大值
                threshold = Integer.MAX_VALUE;
                return oldTab;
            }
            else if ((newCap = oldCap &lt;&lt; 1) &lt; MAXIMUM_CAPACITY &amp;&amp;
                     oldCap &gt;= DEFAULT_INITIAL_CAPACITY)
                //容量翻倍后不超过可设最大容量，旧容量超过课设最小容量
                newThr = oldThr &lt;&lt; 1; // 扩容阈值也翻倍
        }
        else if (oldThr &gt; 0) 
            newCap = oldThr;// 此时oldCap《=0,代表hashmap未初始化，但设置了扩容阈值，初始容量设置为阈值
        else {               // 初始扩容阈值为0时
            newCap = DEFAULT_INITIAL_CAPACITY;//初始容量为默认容量(16)
            //初始扩容阈值 = 初始容量(16) * 负载系数/加载因子(0.75)
            newThr = (int)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);
        }
        if (newThr == 0) {
            //上面第二种情况下未计算新的扩容阈值，这里计算并赋值
            float ft = (float)newCap * loadFactor;
            newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (float)MAXIMUM_CAPACITY ?
                      (int)ft : Integer.MAX_VALUE);
        }
        threshold = newThr;
        @SuppressWarnings({"rawtypes","unchecked"})
        //根据新的容量创建一个新的table
        Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])new Node[newCap];
        table = newTab;
        //将之前的数据转移到新的table
        if (oldTab != null) {
            for (int j = 0; j &lt; oldCap; ++j) {
                Node&lt;K,V&gt; e;
                if ((e = oldTab[j]) != null) {
                    oldTab[j] = null;
                    if (e.next == null)
                        //该Node只有一个数据，根据hash和容量重新计算下标放入新table
                        newTab[e.hash &amp; (newCap - 1)] = e;
                    else if (e instanceof TreeNode)
                        //该Node是一个红黑树Node的情况
                        ((TreeNode&lt;K,V&gt;)e).split(this, newTab, j, oldCap);
                    else { 
                        //该Node是一个有多个数据的链表(1&lt;数据数量&lt;TREEIFY_THRESHOLD(8))
                        //loHead是用来保存新链表上的低位区的头元素的，loTail是用来保存低位区的尾元素的，
                        Node&lt;K,V&gt; loHead = null, loTail = null;
                        //hiHead是用来保存新链表上的高位区的头元素的，hiTail是用来保存高位区的尾元素的，
                        Node&lt;K,V&gt; hiHead = null, hiTail = null;
                        Node&lt;K,V&gt; next;
                        //进行链表遍历至末尾节点，这部分可能会将会将当前链表分列成两个链表，取决于hash的位数
                        do {
                            next = e.next;
                            //等于0时，则将该头节点放到新数组时的索引位置等于其在旧数组时的索引位置,记为低位区链表lo开头-low;
                            if ((e.hash &amp; oldCap) == 0) {
                                if (loTail == null)
                                    loHead = e;
                                else
                                    loTail.next = e;
                                loTail = e;
                            }
                            else {//不等于0时,则将该头节点放到新数组时的索引位置等于其在旧数组时的索引位置再加上旧数组长度，记为高位区链表hi开头high.
                                if (hiTail == null)
                                    hiHead = e;
                                else
                                    hiTail.next = e;
                                hiTail = e;
                            }
                            /**
                             * 这部分举个例子比较好理解呢，举个例子来看，假设oldCap = 16 = 10000，两个数据的hash分别为hash1 = 7 = 0111, hash2 = 23 = 10111
                             * 未扩容的时候两个hash对应的下标分别是:
                             * (hash1 &amp; oldCap -1) = 0111 &amp; 01111 = 111
                             * (hash2 &amp; oldCap -1) = 10111 &amp; 01111 = 111 是同样的位置；
                             * 此时我们将容量扩大一倍 newCap = 32 = 100000，在此计算下标
                             * (hash1 &amp; newCap -1) = 0111 &amp; 11111 = 111;位置不变
                             * hash2 &amp; oldCap -1) = 10111 &amp; 11111 = 10111;位置变了，比原来的位置多了10000，即oldCap
                             * 再来算代码中的e.hash &amp; oldCap == 0这部分
                             * 可以知道hash1 &amp; oldCap = 0111 &amp; 10000 = 0；hash2 &amp; oldCap = 10111 &amp; 10000 = 1；
                             * 所以可以得出，如果e.hash &amp; oldCap == 0，那么对应hash的Node在表扩容后也在数组同样的位置
                             * 而e.hash &amp; oldCap != 0的Node，则会移动，移动的间隔就是oldCap的长度
                             */
                        } while ((e = next) != null);
                        if (loTail != null) {
                            loTail.next = null;
                            newTab[j] = loHead;
                        }
                        if (hiTail != null) {
                            hiTail.next = null;
                            newTab[j + oldCap] = hiHead;
                        }
                    }
                }
            }
        }
        return newTab;
    }
</pre></td></tr></tbody></table></code></pre></div></div>
<p>可以看出其实<strong>HashMap</strong>初始化时是不会初始化我们的数据表<strong>table</strong>，只会初始化一些容量大小和负载因子的值，在第一次使用时才会创建，例如在第四个构造函数，根据传入的<strong>map</strong>构造一个<strong>HashMap</strong>，调用<strong>putVal</strong>方法时内部的<strong>resize</strong>函数会初始化<strong>table</strong>，当单链表数据项超过<strong>TREEIFY_THRESHOLD(8)</strong>，会将单链表<strong>Node</strong>转换成红黑树<strong>TreeNode</strong>，<strong>TreeNode</strong>比较复杂，留到最后讲。</p>

<p>接下来来看一些常用的方法</p>
<h4 id="putkv">put(K,V)</h4>
<p><strong>put(K,V)</strong>:推入指定的键值对的映射。如果该映射先前包含了该键的映射，则旧值将被替换。</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre></td><td class="rouge-code"><pre>public V put(K key, V value) {
        return putVal(hash(key), key, value, false, true);
    }
    
</pre></td></tr></tbody></table></code></pre></div></div>
<h4 id="removeobject">remove(Object)</h4>
<p><strong>remove(Object)</strong>:从该映射中移除指定键的映射(如果存在)。</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
</pre></td><td class="rouge-code"><pre>public V remove(Object key) {
        Node&lt;K,V&gt; e;
        return (e = removeNode(hash(key), key, null, false, true)) == null ?
            null : e.value;
    }
    
final Node&lt;K,V&gt; removeNode(int hash, Object key, Object value,
                               boolean matchValue, boolean movable) {
        Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; int n, index;
        // 判断table和对应的key值Node是否为空
        if ((tab = table) != null &amp;&amp; (n = tab.length) &gt; 0 &amp;&amp;
            (p = tab[index = (n - 1) &amp; hash]) != null) {
            //node存放键值相同的Node
            Node&lt;K,V&gt; node = null, e; K k; V v;
            if (p.hash == hash &amp;&amp;
                ((k = p.key) == key || (key != null &amp;&amp; key.equals(k))))
                //找到了对应的Node，此处结束node = p;
                node = p;
            else if ((e = p.next) != null) {//当前链表头不是对应的键值对映射
                if (p instanceof TreeNode)
                    // 如果是红黑树TreeNode，则在红黑树内寻找
                    node = ((TreeNode&lt;K,V&gt;)p).getTreeNode(hash, key);
                else {
                    //否则在单链表内循环查找，此处结束node = p.next;
                    do {
                        if (e.hash == hash &amp;&amp;
                            ((k = e.key) == key ||
                             (key != null &amp;&amp; key.equals(k)))) {
                            node = e;
                            break;
                        }
                        p = e;
                    } while ((e = e.next) != null);
                }
            }
            //如果matchValue为true,则只移除value相等的键值对映射
            if (node != null &amp;&amp; (!matchValue || (v = node.value) == value ||
                                 (value != null &amp;&amp; value.equals(v)))) {
                if (node instanceof TreeNode)
                    //调用红黑树的方式移除
                    ((TreeNode&lt;K,V&gt;)node).removeTreeNode(this, tab, movable);
                else if (node == p)
                    //node是单链表头
                    tab[index] = node.next; 
                else
                    //此时node就会从单链表中分离
                    p.next = node.next;
                ++modCount;
                --size;
                afterNodeRemoval(node);
                return node;
            }
        }
        return null;
    }
</pre></td></tr></tbody></table></code></pre></div></div>
<h4 id="getobject">get(Object)</h4>
<p><strong>get(Object)</strong>:返回指定键映射到的值，如果该映射不包含该键的映射，则返回null。</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
</pre></td><td class="rouge-code"><pre> public V get(Object key) {
        Node&lt;K,V&gt; e;
        return (e = getNode(hash(key), key)) == null ? null : e.value;
    }
    
 final Node&lt;K,V&gt; getNode(int hash, Object key) {
        Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first, e; int n; K k;
        //判断table是否为空，是否存在数据，是否存在对应键值的Node
        if ((tab = table) != null &amp;&amp; (n = tab.length) &gt; 0 &amp;&amp;
            (first = tab[(n - 1) &amp; hash]) != null) {
            if (first.hash == hash &amp;&amp; // always check first node
                ((k = first.key) == key || (key != null &amp;&amp; key.equals(k))))
                //单链表头就是对应的Node，直接返回
                return first;
            //在链表内搜索hash和key值相同的Node并返回
            if ((e = first.next) != null) {
                if (first instanceof TreeNode)
                    return ((TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key);
                do {
                    if (e.hash == hash &amp;&amp;
                        ((k = e.key) == key || (key != null &amp;&amp; key.equals(k))))
                        return e;
                } while ((e = e.next) != null);
            }
        }
        return null;
    }
</pre></td></tr></tbody></table></code></pre></div></div>
<h4 id="putallmap-extends-k--extends-v">putAll(Map&lt;? extends K, ? extends V&gt;)</h4>
<p><strong>putAll(Map&lt;? extends K, ? extends V&gt;)</strong>:将指定Map的所有键值对映射复制到此映射Map。这些映射将替换该映射对指定映射中对应存在的键值对映射。</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre></td><td class="rouge-code"><pre> public void putAll(Map&lt;? extends K, ? extends V&gt; m) {
        putMapEntries(m, true);
    }
    
</pre></td></tr></tbody></table></code></pre></div></div>
<h4 id="clear">clear()</h4>
<p><strong>clear()</strong>:清空<strong>HashMap</strong>中的所有键值对映射；</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
</pre></td><td class="rouge-code"><pre> public void clear() {
        Node&lt;K,V&gt;[] tab;
        modCount++;
        //将table数组每一位都设置为null;
        if ((tab = table) != null &amp;&amp; size &gt; 0) {
            size = 0;
            for (int i = 0; i &lt; tab.length; ++i)
                tab[i] = null;
        }
    }
</pre></td></tr></tbody></table></code></pre></div></div>
<h2 id="hashtable">HashTable</h2>
<p><strong>Hashtable</strong>继承<strong>Map</strong>接口，实现一个key-value映射的哈希表。任何非空（<strong>non-null</strong>）的对象都可作为key或者value。
<strong>HashTable</strong>的父类接口，以及内部有几个主要的变量，如下：</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
</pre></td><td class="rouge-code"><pre>public class Hashtable&lt;K,V&gt;
    extends Dictionary&lt;K,V&gt;
    implements Map&lt;K,V&gt;, Cloneable, java.io.Serializable
//hash数据表
private transient HashtableEntry&lt;?,?&gt;[] table;
//HashTable中的数据数量
private transient int count;
//(threshold = 容量*负载系数/加载因子)扩容阈值，可以说是一个是否需要扩容的判断条件，当HashMap的size&gt;threshold时会进行resize操作。
int threshold;
private int threshold;
//负载系数/加载因子，可以说是当前HashMap满的程度，
//假设它等于0.75，那么在HashMap的键值对数量超过容量*0.75时，则会进行扩容。
//保证有足够的空间进行数据存放，同时不会经常进行扩容。
final float loadFactor;
private float loadFactor;

//可分配的内部数组的最大大小
private static final int MAX_ARRAY_SIZE = Integer.MAX_VALUE - 8;
</pre></td></tr></tbody></table></code></pre></div></div>
<p><strong>HashtableEntry</strong>:HashTable的数据基类</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
</pre></td><td class="rouge-code"><pre> private static class HashtableEntry&lt;K,V&gt; implements Map.Entry&lt;K,V&gt; {
    // END Android-changed: Renamed Entry -&gt; HashtableEntry.
        final int hash;
        final K key;
        V value;
        HashtableEntry&lt;K,V&gt; next;

        protected HashtableEntry(int hash, K key, V value, HashtableEntry&lt;K,V&gt; next) {
            this.hash = hash;
            this.key =  key;
            this.value = value;
            this.next = next;
        }

        @SuppressWarnings("unchecked")
        protected Object clone() {
            return new HashtableEntry&lt;&gt;(hash, key, value,
                                  (next==null ? null : (HashtableEntry&lt;K,V&gt;) next.clone()));
        }

        // Map.Entry Ops

        public K getKey() {
            return key;
        }

        public V getValue() {
            return value;
        }

        public V setValue(V value) {
            if (value == null)
                throw new NullPointerException();

            V oldValue = this.value;
            this.value = value;
            return oldValue;
        }

        public boolean equals(Object o) {
            if (!(o instanceof Map.Entry))
                return false;
            Map.Entry&lt;?,?&gt; e = (Map.Entry&lt;?,?&gt;)o;

            return (key==null ? e.getKey()==null : key.equals(e.getKey())) &amp;&amp;
               (value==null ? e.getValue()==null : value.equals(e.getValue()));
        }

        public int hashCode() {
            return hash ^ Objects.hashCode(value);
        }

        public String toString() {
            return key.toString()+"="+value.toString();
        }
    }
</pre></td></tr></tbody></table></code></pre></div></div>
<p><strong>HashTable</strong>与<strong>HashMap</strong>非常相似，有很多作用一样的变量。</p>
<h4 id="构造方法-1">构造方法</h4>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
82
83
84
85
86
87
88
89
90
91
92
93
94
95
96
97
98
99
100
101
102
103
104
105
106
107
108
109
110
111
112
113
114
115
116
117
118
119
120
121
122
123
124
</pre></td><td class="rouge-code"><pre> //构造一个新的Hashtable，具有默认的初始容量(11)和加载系数(0.75)。
 public Hashtable() {
        this(11, 0.75f);
    }
    
 //构造一个指定初始容量的新的Hashtable，具有默认的加载系数(0.75)。
 public Hashtable(int initialCapacity) {
        this(initialCapacity, 0.75f);
    }
    
 //构造一个指定初始容量和指定加载系数的新的Hashtable。
 public Hashtable(int initialCapacity, float loadFactor) {
        if (initialCapacity &lt; 0)
            throw new IllegalArgumentException("Illegal Capacity: "+
                                               initialCapacity);
        if (loadFactor &lt;= 0 || Float.isNaN(loadFactor))
            throw new IllegalArgumentException("Illegal Load: "+loadFactor);

        if (initialCapacity==0)
            initialCapacity = 1;
        this.loadFactor = loadFactor;
        table = new HashtableEntry&lt;?,?&gt;[initialCapacity];
        threshold = (int)Math.min(initialCapacity, MAX_ARRAY_SIZE + 1);
    }

 //根据传入的Map一个新的HashTable。HashTable的初始容量足以容纳给定Map中的映射数据，并具有默认的加载因子(0.75)。
 public Hashtable(Map&lt;? extends K, ? extends V&gt; t) {
        this(Math.max(2*t.size(), 11), 0.75f);
        putAll(t);
    }
     
 public synchronized void putAll(Map&lt;? extends K, ? extends V&gt; t) {
        for (Map.Entry&lt;? extends K, ? extends V&gt; e : t.entrySet())
            put(e.getKey(), e.getValue());
    }
    
 //添加键值对，是一个同步的方法
 public synchronized V put(K key, V value) {
        //禁止添加空的value
        if (value == null) {
            throw new NullPointerException();
        }

        HashtableEntry&lt;?,?&gt; tab[] = table;
        int hash = key.hashCode();
        //根据key的hash值和表容量计算下标
        //0x7FFFFFFF是一个用16进制表示的整型,是整型里面的最大值
        //转成2进制由31个1组成，而整形的最高是32位
        //hash与其按位与得到一个正数
        int index = (hash &amp; 0x7FFFFFFF) % tab.length;
        @SuppressWarnings("unchecked")
        //获得对应下标的单链表
        HashtableEntry&lt;K,V&gt; entry = (HashtableEntry&lt;K,V&gt;)tab[index];
        //如果存在key值相同的键值对，则替换value
        for(; entry != null ; entry = entry.next) {
            if ((entry.hash == hash) &amp;&amp; entry.key.equals(key)) {
                V old = entry.value;
                entry.value = value;
                return old;
            }
        }
        
        addEntry(hash, key, value, index);
        return null;
    }
    
private void addEntry(int hash, K key, V value, int index) {
        modCount++;

        HashtableEntry&lt;?,?&gt; tab[] = table;
        //判断当前容量是否超出或等于扩容阈值
        if (count &gt;= threshold) {
            // 如果超过阈值，则扩容
            rehash();
            
            //扩容后重新计算下标index
            tab = table;
            hash = key.hashCode();
            index = (hash &amp; 0x7FFFFFFF) % tab.length;
        }

        //创建新的HashtableEntry，并赋值
        @SuppressWarnings("unchecked")
        HashtableEntry&lt;K,V&gt; e = (HashtableEntry&lt;K,V&gt;) tab[index];
        tab[index] = new HashtableEntry&lt;&gt;(hash, key, value, e);
        //数据量+1
        count++;
    }
    
  //扩容，并对内部的键值对重新排列
  protected void rehash() {
        int oldCapacity = table.length;
        HashtableEntry&lt;?,?&gt;[] oldMap = table;

        //新容量为两倍旧容量+1
        int newCapacity = (oldCapacity &lt;&lt; 1) + 1;
        //判断新容量是否超出最大容量
        if (newCapacity - MAX_ARRAY_SIZE &gt; 0) {
            if (oldCapacity == MAX_ARRAY_SIZE)
                // Keep running with MAX_ARRAY_SIZE buckets
                return;
            newCapacity = MAX_ARRAY_SIZE;
        }
        //使用新容量创建一个新的数组table
        HashtableEntry&lt;?,?&gt;[] newMap = new HashtableEntry&lt;?,?&gt;[newCapacity];

        modCount++;
        //计算新的扩容阈值
        threshold = (int)Math.min(newCapacity * loadFactor, MAX_ARRAY_SIZE + 1);
        table = newMap;
        
        //将旧map数组的数据导入新map数组,重新计算下标
        for (int i = oldCapacity ; i-- &gt; 0 ;) {
            for (HashtableEntry&lt;K,V&gt; old = (HashtableEntry&lt;K,V&gt;)oldMap[i] ; old != null ; ) {
                HashtableEntry&lt;K,V&gt; e = old;
                old = old.next;

                int index = (e.hash &amp; 0x7FFFFFFF) % newCapacity;
                e.next = (HashtableEntry&lt;K,V&gt;)newMap[index];
                newMap[index] = e;
            }
        }
    }
    
</pre></td></tr></tbody></table></code></pre></div></div>
<p>可以看出其实<strong>HashTable</strong>与<strong>HashMap</strong>的初始化类似，在初始化时是不会初始化我们的数据表<strong>table</strong>，只会初始化一些容量大小和负载因子的值，在第一次使用时才会创建。例如<strong>putAll</strong>。</p>
<h4 id="putkv-1">put(K,V)</h4>
<p><strong>put(K,V)</strong>:推入指定的键值对的映射。如果该映射先前包含了该键的映射，则旧值将被替换。<strong>key</strong>和<strong>value</strong>都不能为null。</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
</pre></td><td class="rouge-code"><pre> public synchronized V put(K key, V value) {
        //确保valu不为null
        if (value == null) {
            throw new NullPointerException();
        }

        HashtableEntry&lt;?,?&gt; tab[] = table;
        //计算下标
        int hash = key.hashCode();
        int index = (hash &amp; 0x7FFFFFFF) % tab.length;
        @SuppressWarnings("unchecked")
        //获得对应下标的单链表
        HashtableEntry&lt;K,V&gt; entry = (HashtableEntry&lt;K,V&gt;)tab[index];
        //如果存在在key值已存在，则替换value
        for(; entry != null ; entry = entry.next) {
            if ((entry.hash == hash) &amp;&amp; entry.key.equals(key)) {
                V old = entry.value;
                entry.value = value;
                return old;
            }
        }
        //不存在添加键值对
        addEntry(hash, key, value, index);
        return null;
    }
</pre></td></tr></tbody></table></code></pre></div></div>
<h4 id="removeobject-1">remove(Object)</h4>
<p><strong>remove(Object)</strong>:从这个<strong>HashTable</strong>移除<strong>key</strong>(及其对应的<strong>value</strong>)。如果<strong>key</strong>不在<strong>HashTable</strong>中，此方法不执行任何操作。</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
</pre></td><td class="rouge-code"><pre> public synchronized V remove(Object key) {
        //计算下标
        HashtableEntry&lt;?,?&gt; tab[] = table;
        int hash = key.hashCode();
        int index = (hash &amp; 0x7FFFFFFF) % tab.length;
        
        @SuppressWarnings("unchecked")
        HashtableEntry&lt;K,V&gt; e = (HashtableEntry&lt;K,V&gt;)tab[index];
        //判断是否存在对应的key值
        for(HashtableEntry&lt;K,V&gt; prev = null ; e != null ; prev = e, e = e.next) {
            if ((e.hash == hash) &amp;&amp; e.key.equals(key)) {
                modCount++;
                if (prev != null) {
                    prev.next = e.next;
                } else {
                    tab[index] = e.next;
                }
                count--;
                V oldValue = e.value;
                e.value = null;
                return oldValue;
            }
        }
        return null;
    }

</pre></td></tr></tbody></table></code></pre></div></div>
<h4 id="getobject-1">get(Object)</h4>
<p><strong>get(Object)</strong>:返回指定<strong>key</strong>对应的<strong>value</strong>,若<strong>key</strong>不在<strong>HashTable</strong>中，则返回<strong>null</strong></p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
</pre></td><td class="rouge-code"><pre> public synchronized V get(Object key) {
        //计算下标
        HashtableEntry&lt;?,?&gt; tab[] = table;
        int hash = key.hashCode();
        int index = (hash &amp; 0x7FFFFFFF) % tab.length;
        //找key对应的value
        for (HashtableEntry&lt;?,?&gt; e = tab[index] ; e != null ; e = e.next) {
            if ((e.hash == hash) &amp;&amp; e.key.equals(key)) {
                return (V)e.value;
            }
        }
        return null;
    }
</pre></td></tr></tbody></table></code></pre></div></div>
<h4 id="clear-1">clear()</h4>
<p><strong>clear()</strong>:清空此<strong>HashTable</strong></p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
</pre></td><td class="rouge-code"><pre>  public synchronized void clear() {
        HashtableEntry&lt;?,?&gt; tab[] = table;
        modCount++;
        for (int index = tab.length; --index &gt;= 0; )
            tab[index] = null;
        count = 0;
    }
</pre></td></tr></tbody></table></code></pre></div></div>
<p><strong>HashTable</strong>的方法基本都是<strong>synchronized</strong>的，相对于<strong>HashMap</strong>是同步的。</p>
<h2 id="hashmap与hashtable的不同">HashMap与HashTable的不同</h2>
<h3 id="一-线程安全性">一 线程安全性</h3>
<ul>
  <li><strong>HashTable</strong>方法添加了<strong>synchronized</strong>关键字，是同步的，是线程安全的</li>
  <li>
    <ul>
      <li><strong>HashMap</strong>是非同步的，线程不安全</li>
    </ul>
  </li>
</ul>

<h3 id="二-内部方法">二 内部方法</h3>
<ul>
  <li><strong>Hashtable</strong>则保留了<strong>contains</strong>，<strong>containsValue</strong>和<strong>containsKey</strong>三个方法，其中<strong>contains</strong>和<strong>containsValue</strong>功能相同。</li>
  <li><strong>HashMap</strong>没有<strong>contains</strong>方法去掉了，改成<strong>containsValue</strong>和<strong>containsKey</strong>，因为<strong>contains</strong>方法容易让人引起误解。</li>
</ul>

<p>方法内容对比：
<strong>HashTable</strong></p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
</pre></td><td class="rouge-code"><pre>  
  public synchronized boolean contains(Object value) {
        //value不能为null
        if (value == null) {
            throw new NullPointerException();
        }
        //包含返回true,不包含返回false
        HashtableEntry&lt;?,?&gt; tab[] = table;
        for (int i = tab.length ; i-- &gt; 0 ;) {
            for (HashtableEntry&lt;?,?&gt; e = tab[i] ; e != null ; e = e.next) {
                if (e.value.equals(value)) {
                    return true;
                }
            }
        }
        return false;
    }
  //查看是否包含value
  public boolean containsValue(Object value) {
        return contains(value);
    }
    
  //查看是否包含key
  public synchronized boolean containsKey(Object key) {
        HashtableEntry&lt;?,?&gt; tab[] = table;
        int hash = key.hashCode();
        int index = (hash &amp; 0x7FFFFFFF) % tab.length;
        for (HashtableEntry&lt;?,?&gt; e = tab[index] ; e != null ; e = e.next) {
             //包含返回true,不包含返回false
            if ((e.hash == hash) &amp;&amp; e.key.equals(key)) {
                return true;
            }
        }
        return false;
    }
</pre></td></tr></tbody></table></code></pre></div></div>
<p><strong>HashMap</strong></p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
</pre></td><td class="rouge-code"><pre> public boolean containsValue(Object value) {
        Node&lt;K,V&gt;[] tab; V v;
        if ((tab = table) != null &amp;&amp; size &gt; 0) {
            for (int i = 0; i &lt; tab.length; ++i) {
                for (Node&lt;K,V&gt; e = tab[i]; e != null; e = e.next) {
                    if ((v = e.value) == value ||
                        (value != null &amp;&amp; value.equals(v)))
                        return true;
                }
            }
        }
        return false;
    }

  public boolean containsKey(Object key) {
        return getNode(hash(key), key) != null;
    }
</pre></td></tr></tbody></table></code></pre></div></div>
<h3 id="key和value的限制">key和value的限制</h3>
<p>根据上面的<strong>containsValue</strong>和<strong>containsKey</strong>方法得出：
<strong>Hashtable</strong>:<strong>key</strong>和<strong>value</strong>都不允许出现<strong>null</strong>值；
<strong>HashMap</strong>:<strong>null</strong>可以作为<strong>key</strong>，这样的<strong>key</strong>只有一个；但是可以有一个或多个<strong>key</strong>所对应的值为<strong>null</strong>。当<strong>get()</strong>方法返回n<strong>ull</strong>值时，可能是 <strong>HashMap</strong>中没有该键，也可能使该键所对应的值为<strong>null</strong>。因此，在<strong>HashMap</strong>中不能由<strong>get()</strong>方法来判断<strong>HashMap</strong>中是否存在某个<strong>key</strong>， 而应该用<strong>containsKey()</strong>方法来判断。</p>
<h3 id="两个遍历方式的内部实现上不同">两个遍历方式的内部实现上不同</h3>
<p><strong>Hashtable</strong>:使用了 <strong>Iterator</strong>
<strong>HashMap</strong>:使用了 <strong>Iterator</strong>。由于历史原因，还使用了<strong>Enumeration</strong>的方式 。</p>
<h3 id="hash值不同">hash值不同</h3>
<p><strong>Hashtable</strong>:直接使用对象的<strong>hashCode</strong>,<strong>hashCode</strong>是jdk根据对象的地址或者字符串或者数字算出来的<strong>int</strong>类型的数值。<strong>Hashtable</strong>在求<strong>hash</strong>值对应的位置索引时，用取模运算;
<strong>HashMap</strong>:重新计算<strong>hash</strong>值,在求位置索引时，则用与运算;</p>

<h3 id="内部实现使用的数组初始化和扩容方式不同">内部实现使用的数组初始化和扩容方式不同</h3>
<p><strong>Hashtable</strong>:在不指定容量的情况下的默认容量为11,<strong>Hashtable</strong>不要求底层数组的容量一定要为2的整数次幂;扩容时，<strong>Hashtable</strong>将容量变为原来的2倍加1
<strong>HashMap</strong>:在不指定容量的情况下的默认容量为16,<strong>HashMap</strong>要求底层数组的容量一定为2的整数次幂,扩容时，<strong>HashMap</strong>将容量变为原来的2倍。</p>

<h2 id="treemap">TreeMap</h2>
<p><strong>TreeMap</strong>是一个非同步有序的<strong>key-value</strong>集合，它通过<strong>红黑树</strong>实现，实现了<strong>NavigableMap</strong>接口，意味着它支持一系列的导航方法。比如返回<strong>有序的key集合</strong>。该映射根据其键的自然顺序进行排序，或者根据创建映射时提供的 <strong>Comparator</strong> 进行排序，具体取决于使用的构造方法。
<strong>TreeMap</strong>的基本操作 <strong>containsKey</strong>、<strong>get</strong>、<strong>put</strong> 和 <strong>remove</strong> 的时间复杂度是 <strong>log(n)</strong> 。使用不多，就暂不介绍了。</p>


                <hr style="visibility: hidden;">
                <ul class="pager">
                    
                    <li class="previous">
                        <a href="/article/2020/11/29/JAVA%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AE%80%E5%8D%95%E6%A6%82%E6%8B%AC/" data-toggle="tooltip" data-placement="top" title="JAVA数据结构简单概括">
                        Previous<br>
                        <span>JAVA数据结构简单概括</span>
                        </a>
                    </li>
                    
                    
                    <li class="next">
                        <a href="/article/2020/12/30/JAVA%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%86%85%E9%83%A8%E5%8F%8A%E5%9F%BA%E7%A1%80%E6%96%B9%E6%B3%95%E5%AE%9E%E7%8E%B0%E4%BA%8C-Collection/" data-toggle="tooltip" data-placement="top" title="JAVA数据结构内部及基础方法实现二（Collection）">
                        Next<br>
                        <span>JAVA数据结构内部及基础方法实现二（Collection）</span>
                        </a>
                    </li>
                    
                </ul>
                <hr style="visibility: hidden;">

                

                
            </div>  

    <!-- Side Catalog Container -->
        
            <div class="
                col-lg-2 col-lg-offset-0
                visible-lg-block
                sidebar-container
                catalog-container">
                <div class="side-catalog">
                    <hr class="hidden-sm hidden-xs">
                    <h5>
                        <a class="catalog-toggle" href="#">CATALOG</a>
                    </h5>
                    <ul class="catalog-body"></ul>
                </div>
            </div>
        

    <!-- Sidebar Container -->
            <div class="
                col-lg-8 col-lg-offset-2
                col-md-10 col-md-offset-1
                sidebar-container">

                <!-- Featured Tags -->
                


<section>
    
        <hr class="hidden-sm hidden-xs">
    
    <h5><a href="/archive/">FEATURED TAGS</a></h5>
    <div class="tags">
        
        
        
        
        
        
                <a data-sort="0005" 
                    href="/archive/?tag=Android"
                    title="Android"
                    rel="6">Android</a>
        
                <a data-sort="0007" 
                    href="/archive/?tag=Framework"
                    title="Framework"
                    rel="4">Framework</a>
        
                <a data-sort="0008" 
                    href="/archive/?tag=%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"
                    title="数据结构"
                    rel="3">数据结构</a>
        
                <a data-sort="0008" 
                    href="/archive/?tag=JAVA"
                    title="JAVA"
                    rel="3">JAVA</a>
    </div>
</section>


                <!-- Friends Blog -->
                
<hr>
<h5>FRIENDS</h5>
<ul class="list-inline">
  
  <li><a href="https://gitee.com/5027">陈宇瀚gitee</a></li>
  
  <li><a href="https://www.jianshu.com/u/c241df6b66d1">简书</a></li>
  
  <li><a href="https://kkyflying.github.io/">Kky</a></li>
  
  <li><a href="https://kkyflying.github.io/">Kky</a></li>
  
  <li><a href="https://gitee.com/kevin.qiu">Kevin Qiu</a></li>
  
  <li><a href="https://gitee.com/rainccrun">rainccrun</a></li>
  
  <li><a href="https://gitee.com/lzxnagi">lzxnagi</a></li>
  
</ul>

            </div>
        </div>
    </div>
</article>

<!-- add support for mathjax by voleking-->









<!-- async load function -->
<script>
    function async(u, c) {
      var d = document, t = 'script',
          o = d.createElement(t),
          s = d.getElementsByTagName(t)[0];
      o.src = u;
      if (c) { o.addEventListener('load', function (e) { c(null, e); }, false); }
      s.parentNode.insertBefore(o, s);
    }
</script>
<!-- anchor-js, Doc:http://bryanbraun.github.io/anchorjs/ -->
<script>
    async("//cdnjs.cloudflare.com/ajax/libs/anchor-js/1.1.1/anchor.min.js",function(){
        anchors.options = {
          visible: 'hover',
          placement: 'right',
          // icon: '#'
        };
        anchors.add().remove('.intro-header h1').remove('.subheading').remove('.sidebar-container h5');
    })
</script>
<style>
    /* place left on bigger screen */
    @media all and (min-width: 800px) {
        .anchorjs-link{
            position: absolute;
            left: -0.75em;
            font-size: 1.1em;
            margin-top : -0.1em;
        }
    }
</style>



    <!-- Footer -->
<footer>
    <div class="container">
        <div class="row">
            <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
                <!-- SNS Link -->
                


<ul class="list-inline text-center">


  
  
  
  
  <li>
    <a target="_blank" href="http://weibo.com/陈瀚仔">
      <span class="fa-stack fa-lg">
        <i class="fa fa-circle fa-stack-2x"></i>
        <i class="fa fa-weibo fa-stack-1x fa-inverse"></i>
      </span>
    </a>
  </li>
  
  
  
  <li>
    <a target="_blank" href="https://github.com/YuHanChen5027">
      <span class="fa-stack fa-lg">
        <i class="fa fa-circle fa-stack-2x"></i>
        <i class="fa fa-github fa-stack-1x fa-inverse"></i>
      </span>
    </a>
  </li>
  
  
</ul>

                <p class="copyright text-muted">
                    Copyright &copy; ChenYuHan Blog 2021
                    <br>
                    Powered by <a href="http://huangxuan.me">Hux Blog</a> |
                    <iframe style="margin-left: 2px; margin-bottom:-5px;" frameborder="0" scrolling="0" width="100px"
                        height="20px"
                        src="https://ghbtns.com/github-btn.html?user=huxpro&repo=huxpro.github.io&type=star&count=true">
                    </iframe>
                </p>
            </div>
        </div>
    </div>
</footer>

<!-- jQuery -->
<script src="/js/jquery.min.js "></script>

<!-- Bootstrap Core JavaScript -->
<!-- Currently, only navbar scroll-down effect at desktop still depends on this -->
<script src="/js/bootstrap.min.js "></script>

<!-- Custom Theme JavaScript -->
<script src="/js/hux-blog.min.js "></script>

<!-- Simple Jekyll Search -->
<script src="/js/simple-jekyll-search.min.js"></script>

<!-- Service Worker -->

<script src="/js/snackbar.js "></script>
<script src="/js/sw-registration.js "></script>


<!-- async load function -->
<script>
    function async(u, c) {
        var d = document, t = 'script',
            o = d.createElement(t),
            s = d.getElementsByTagName(t)[0];
        o.src = u;
        if (c) { o.addEventListener('load', function (e) { c(null, e); }, false); }
        s.parentNode.insertBefore(o, s);
    }
</script>

<!--
     Because of the native support for backtick-style fenced code blocks
     right within the Markdown is landed in Github Pages,
     From V1.6, There is no need for Highlight.js,
     so Huxblog drops it officially.

     - https://github.com/blog/2100-github-pages-now-faster-and-simpler-with-jekyll-3-0
     - https://help.github.com/articles/creating-and-highlighting-code-blocks/
     - https://github.com/jneen/rouge/wiki/list-of-supported-languages-and-lexers
-->
<!--
    <script>
        async("http://cdn.bootcss.com/highlight.js/8.6/highlight.min.js", function(){
            hljs.initHighlightingOnLoad();
        })
    </script>
    <link href="http://cdn.bootcss.com/highlight.js/8.6/styles/github.min.css" rel="stylesheet">
-->







<!--fastClick.js -->
<script>
    async("//cdnjs.cloudflare.com/ajax/libs/fastclick/1.0.6/fastclick.min.js", function () {
        var $nav = document.querySelector("nav");
        if ($nav) FastClick.attach($nav);
    })
</script>


<!-- Google Analytics -->



<!-- Baidu Tongji -->



<!-- Side Catalog -->

<script type="text/javascript">
    function generateCatalog(selector) {

        // interop with multilangual 
        if ('' == 'true') {
            _containerSelector = 'div.post-container.active'
        } else {
            _containerSelector = 'div.post-container'
        }

        // init
        var P = $(_containerSelector), a, n, t, l, i, c;
        a = P.find('h1,h2,h3,h4,h5,h6');

        // clean
        $(selector).html('')

        // appending
        a.each(function () {
            n = $(this).prop('tagName').toLowerCase();
            i = "#" + $(this).prop('id');
            t = $(this).text();
            c = $('<a href="' + i + '" rel="nofollow">' + t + '</a>');
            l = $('<li class="' + n + '_nav"></li>').append(c);
            $(selector).append(l);
        });
        return true;
    }

    generateCatalog(".catalog-body");

    // toggle side catalog
    $(".catalog-toggle").click((function (e) {
        e.preventDefault();
        $('.side-catalog').toggleClass("fold")
    }))

    /*
     * Doc: https://github.com/davist11/jQuery-One-Page-Nav
     * Fork by Hux to support padding
     */
    async("/js/jquery.nav.js", function () {
        $('.catalog-body').onePageNav({
            currentClass: "active",
            changeHash: !1,
            easing: "swing",
            filter: "",
            scrollSpeed: 700,
            scrollOffset: 0,
            scrollThreshold: .2,
            begin: null,
            end: null,
            scrollChange: null,
            padding: 80
        });
    });
</script>



<!-- Multi-Lingual -->


<!-- Simple Jekyll Search -->
<script>
    // https://stackoverflow.com/questions/1912501/unescape-html-entities-in-javascript
    function htmlDecode(input) {
        var e = document.createElement('textarea');
        e.innerHTML = input;
        // handle case of empty input
        return e.childNodes.length === 0 ? "" : e.childNodes[0].nodeValue;
    }

    SimpleJekyllSearch({
        searchInput: document.getElementById('search-input'),
        resultsContainer: document.getElementById('search-results'),
        json: '/search.json',
        searchResultTemplate: '<div class="post-preview item"><a href="{url}"><h2 class="post-title">{title}</h2><h3 class="post-subtitle">{subtitle}</h3><hr></a></div>',
        noResultsText: 'No results',
        limit: 50,
        fuzzy: false,
        // a hack to get escaped subtitle unescaped. for some reason, 
        // post.subtitle w/o escape filter nuke entire search.
        templateMiddleware: function (prop, value, template) {
            if (prop === 'subtitle' || prop === 'title') {
                if (value.indexOf("code")) {
                    return htmlDecode(value);
                } else {
                    return value;
                }
            }
        }
    });

    $(document).ready(function () {
        var $searchPage = $('.search-page');
        var $searchOpen = $('.search-icon');
        var $searchClose = $('.search-icon-close');
        var $searchInput = $('#search-input');
        var $body = $('body');

        $searchOpen.on('click', function (e) {
            e.preventDefault();
            $searchPage.toggleClass('search-active');
            var prevClasses = $body.attr('class') || '';
            setTimeout(function () {
                $body.addClass('no-scroll');
            }, 400)

            if ($searchPage.hasClass('search-active')) {
                $searchClose.on('click', function (e) {
                    e.preventDefault();
                    $searchPage.removeClass('search-active');
                    $body.attr('class', prevClasses);  // from closure 
                });
                $searchInput.focus();
            }
        });
    });
</script>


<!-- Image to hack wechat -->
<img src="/img/icon_wechat.png" width="0" height="0" />
<!-- Migrate from head to bottom, no longer block render and still work -->

</body>

</html>
