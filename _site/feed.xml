<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>ChenYuHan Blog</title>
    <description>关于Android开发| 这里是 陈宇瀚 的个人博客，一个有梦想还没秃的Android程序员。</description>
    <link>https://yuhanchen5027.github.io//</link>
    <atom:link href="https://yuhanchen5027.github.io//feed.xml" rel="self" type="application/rss+xml" />
    <pubDate>Sun, 03 Jan 2021 17:39:44 +0800</pubDate>
    <lastBuildDate>Sun, 03 Jan 2021 17:39:44 +0800</lastBuildDate>
    <generator>Jekyll v4.2.0</generator>
    
      <item>
        <title>JAVA数据结构内部及基础方法实现二（Collection）</title>
        <description>&lt;p&gt;JAVA有几种常用的数据结构，主要是继承&lt;strong&gt;Collection&lt;/strong&gt;和&lt;strong&gt;Map&lt;/strong&gt;这两个主要接口的数据实现类&lt;/p&gt;

&lt;p&gt;在jdk1.7和jdk1.8中，实现会有些许不同，之后会在注解中添加两版本区别
下面分别介绍几个常用的数据结构(按照继承的接口分为两类)，以下代码截取自&lt;strong&gt;基于JAVA8的android SDK 28&lt;/strong&gt;&lt;/p&gt;
&lt;h1 id=&quot;collection&quot;&gt;Collection&lt;/h1&gt;
&lt;p&gt;&lt;strong&gt;Collection&lt;/strong&gt;是最基本的集合接口，一个&lt;strong&gt;Collection&lt;/strong&gt;代表一组&lt;strong&gt;Object&lt;/strong&gt;，即&lt;strong&gt;Collection&lt;/strong&gt;的元素&lt;strong&gt;Elements&lt;/strong&gt;。一些&lt;strong&gt;Collection&lt;/strong&gt;允许相同的元素而另一些不行。一些能排序而另一些不行。&lt;strong&gt;Java SDK&lt;/strong&gt;不提供直接继承自&lt;strong&gt;Collection&lt;/strong&gt;的类，&lt;strong&gt;Java SDK&lt;/strong&gt;提供的类都是继承自&lt;strong&gt;Collection的&lt;/strong&gt;“子接口”如&lt;strong&gt;List&lt;/strong&gt;和&lt;strong&gt;Set&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;论&lt;strong&gt;Collection&lt;/strong&gt;的实际类型如何，它都支持一个&lt;strong&gt;iterator&lt;/strong&gt;()的方法，该方法返回一个&lt;strong&gt;迭代子&lt;/strong&gt;，使用该迭代子即可逐一访问&lt;strong&gt;Collection&lt;/strong&gt;中每一个元素。典型的用法如下：&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;Iterator it = collection.iterator(); // 获得一个迭代子
　　　　while(it.hasNext()) {
　　　　　　Object obj = it.next(); // 得到下一个元素
　　　　}
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;由&lt;strong&gt;Collection&lt;/strong&gt;接口派生的两个接口是&lt;strong&gt;List&lt;/strong&gt;和&lt;strong&gt;Set&lt;/strong&gt;。&lt;/p&gt;
&lt;h2 id=&quot;list&quot;&gt;List&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;List&lt;/strong&gt;是有序的&lt;strong&gt;Collection&lt;/strong&gt;，使用此接口能够精确的控制每个元素插入的位置。用户能够使用索引（元素在&lt;strong&gt;List&lt;/strong&gt;中的位置，类似于数组下标）来访问&lt;strong&gt;List&lt;/strong&gt;中的元素，这类似于&lt;strong&gt;Java&lt;/strong&gt;的数组，与之后介绍的&lt;strong&gt;Set&lt;/strong&gt;不一样，&lt;strong&gt;List&lt;/strong&gt;允许有相同的元素。实现&lt;strong&gt;List&lt;/strong&gt;接口的常用类有&lt;strong&gt;LinkedList&lt;/strong&gt;，&lt;strong&gt;ArrayList&lt;/strong&gt;，&lt;strong&gt;Vector&lt;/strong&gt;和&lt;strong&gt;Stack&lt;/strong&gt;。&lt;/p&gt;

&lt;h3 id=&quot;linkedlistjava78中基本没有改动&quot;&gt;LinkedList（JAVA7/8中基本没有改动）&lt;/h3&gt;
&lt;p&gt;双向链表结构，适用于乱序插入、删除。但指定序列操作性能不如&lt;strong&gt;ArrayList&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;LinkedList&lt;/strong&gt;的父类接口，以及内部有几个主要的变量，如下：&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
10
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;public class LinkedList&amp;lt;E&amp;gt;
    extends AbstractSequentialList&amp;lt;E&amp;gt;
    implements List&amp;lt;E&amp;gt;, Deque&amp;lt;E&amp;gt;, Cloneable, java.io.Serializable
    
transient int size = 0;//链表尺寸
transient Node&amp;lt;E&amp;gt; first;//链表第一个节点指针
transient Node&amp;lt;E&amp;gt; last;//链表末尾节点指针

##注transient关键字：将不需要序列化的属性前添加关键字transient，序列化对象的时候，这个属性就不会被序列化。

&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;&lt;em&gt;注：实现了Cloneable接口，即实现clone()函数。代表能被克隆。&lt;/em&gt;
数据类&lt;strong&gt;Node&lt;/strong&gt;的结构&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
10
11
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;  private static class Node&amp;lt;E&amp;gt; {
        E item;//节点数据
        Node&amp;lt;E&amp;gt; next;//当前节点下一个节点
        Node&amp;lt;E&amp;gt; prev;//当前节点上一个节点

        Node(Node&amp;lt;E&amp;gt; prev, E element, Node&amp;lt;E&amp;gt; next) {
            this.item = element;
            this.next = next;
            this.prev = prev;
        }
    }
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;h4 id=&quot;构造方法&quot;&gt;构造方法&lt;/h4&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
10
11
12
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt; public LinkedList() {
 }
 //构造一个包含指定元素的列表
 public LinkedList(Collection&amp;lt;? extends E&amp;gt; c) {
        this();
        addAll(c);
}
    
public boolean addAll(Collection&amp;lt;? extends E&amp;gt; c) {
        //可参考下方的addAll解析，就是在size(此时size = 0)后加入指定元素的列表的数据
        return addAll(size, c);
}
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;以下是使用时的常用方法实现代码以及分析:&lt;/p&gt;

&lt;p&gt;&lt;em&gt;注：modCount是父类AbstractList中定义的一个int型的属性记录了ArrayList结构性变化的次数。List中add()、remove()、addAll()、removeRange()及clear()这些方法每调用一次，modCount的值就加1。&lt;/em&gt;&lt;/p&gt;

&lt;h4 id=&quot;addaddlasteaddinte&quot;&gt;add()/addLast(E)/add(int,E)&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;add(E)/addLast(E)&lt;/strong&gt;:将指定的元素添加到列表的末尾。&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;public boolean add(E e) {
        linkLast(e);
        return true;
    }
public void addLast(E e) {
        linkLast(e);
    }
    
    void linkLast(E e) {
        final Node&amp;lt;E&amp;gt; l = last;//获取末尾节点
        final Node&amp;lt;E&amp;gt; newNode = new Node&amp;lt;&amp;gt;(l, e, null);//将传入的数据封装成 Node
        last = newNode; 
        if (l == null)//判断是否存在末尾节点
            first = newNode;//不存在则说明链表为空，直接将节点赋值为 newNode
        else
            l.next = newNode;//否则将末尾节点的next赋值为 newNode
        size++;
        modCount++;
    }
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;add(int,E)&lt;/strong&gt;:在列表的指定位置插入指定的元素。&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt; public void add(int index, E element) {
        //判断index下标是否在链表范围内(0=&amp;lt;index&amp;lt;=size),超出则抛出IndexOutOfBoundsException 
        checkPositionIndex(index);

        if (index == size)
            linkLast(element); //此时相当于插入末尾，与add(E)方法一致
        else
            linkBefore(element, node(index));//重点看这个方法，插入链表中间
    }
    
     /**
     * 在节点index前插入新节点
     */
    void linkBefore(E e, Node&amp;lt;E&amp;gt; succ) {
        final Node&amp;lt;E&amp;gt; pred = succ.prev;//获得index位置节点的前置节点
        //创建新节点，前置节点为index位置节点的前置节点，后置节点为index位置节点
        final Node&amp;lt;E&amp;gt; newNode = new Node&amp;lt;&amp;gt;(pred, e, succ);
        succ.prev = newNode;//改变index位置节点的前置节点为新节点
        if (pred == null) //判断index位置节点的前置节点是否为空
            first = newNode;    //为空代表插在链表头
        else
            pred.next = newNode;    //不为空将节点的后置节点设置为新节点
        size++;
        modCount++;
        
    }
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;h4 id=&quot;removeint&quot;&gt;remove(int)&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;remove(int)&lt;/strong&gt;：删除列表中指定位置的元素。&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt; public E remove(int index) {
        /**判断index下标是否在链表索引范围内(0=&amp;lt;index&amp;lt;size),超出则抛出IndexOutOfBoundsException**/
        checkElementIndex(index);
        return unlink(node(index));//node(index)获取到了index下表的Node
    }
    
    E unlink(Node&amp;lt;E&amp;gt; x) {
        // assert x != null;
        final E element = x.item;
        final Node&amp;lt;E&amp;gt; next = x.next;
        final Node&amp;lt;E&amp;gt; prev = x.prev;
        //判断前置节点是否为null。
        if (prev == null) {
            first = next;//为空则代表是第一个节点，将后置节点设置为首位节点
        } else {
            //不为空则代表是中间节点，将前置节点的后置节点设置为自己的后直节点，断开自己与前置节点的链接。
            prev.next = next 
            x.prev = null;
        }
        //同样的方式判断后置
        if (next == null) {
            last = prev;
        } else {
            next.prev = prev;
            x.next = null;
        }
            
        x.item = null;//当前节点的数据置null
        size--;
        modCount++;
        return element; 
    }
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;h4 id=&quot;getint&quot;&gt;get(int)&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;get(int)&lt;/strong&gt;:Returns the element at the specified position in this list.&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;public E get(int index){
        /**判断index下标是否在链表索引范围内(0=&amp;lt;index&amp;lt;size),超出则抛出IndexOutOfBoundsException**/
        checkElementIndex(index);
        return node(index).item;
    }
    
    /**
    *   返回指定元素索引处的(非空)节点。
    */
    Node&amp;lt;E&amp;gt; node(int index) {
        /**size &amp;gt;&amp;gt; 1相当于size/2**/
        if (index &amp;lt; (size &amp;gt;&amp;gt; 1)) { 
          /**如果获取index小于size/2，则从首位节点开始循环获取**/
            Node&amp;lt;E&amp;gt; x = first;  
            for (int i = 0; i &amp;lt; index; i++)
                x = x.next;
            return x;
        } else {
          /**如果获取index大于size/2，则从末尾节点开始循环获取**/
            Node&amp;lt;E&amp;gt; x = last;
            for (int i = size - 1; i &amp;gt; index; i--)
                x = x.prev;
            return x;
        }
    }
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;h4 id=&quot;setinte&quot;&gt;set(int,E)&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;set(int,E)&lt;/strong&gt;:将列表中指定位置的元素替换为指定的元素。&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;  public E set(int index, E element) {
        /**判断index下标是否在链表索引范围内(0=&amp;lt;index&amp;lt;size),超出则抛出IndexOutOfBoundsException**/
        checkElementIndex(index);
        Node&amp;lt;E&amp;gt; x = node(index);
        E oldVal = x.item;
        x.item = element;
        return oldVal;
    }
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;h4 id=&quot;addallcollection-extends-eaddallint--collection-extends-e&quot;&gt;addAll(Collection&amp;lt;? extends E&amp;gt;)/addAll(int , Collection&amp;lt;? extends E&amp;gt;)&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;addAll(Collection&amp;lt;? extends E&amp;gt;)/addAll(int , Collection&amp;lt;? extends E&amp;gt;)&lt;/strong&gt;
：将指定集合中的所有元素添加到末尾/index节点之后&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;   //本质上是调用同个方法
   public boolean addAll(Collection&amp;lt;? extends E&amp;gt; c) {
        return addAll(size, c);//传入size,直接在末尾插入
    }
    
    public boolean addAll(int index, Collection&amp;lt;? extends E&amp;gt; c) {
        //判断插入位置index是否超出范围
        checkPositionIndex(index);
        //将集合转成数组
        Object[] a = c.toArray();
        int numNew = a.length;
        //集合数为0，等于没有数据
        if (numNew == 0)
            return false;

        //predpred是插入节点集合的前置节点
        //succ是插入位置节点，用于之后判断是中间插入还是末尾插入
        Node&amp;lt;E&amp;gt; pred, succ;
        if (index == size) {
            //index等于链表尺寸，代表是末尾插入
            succ = null;
            pred = last;
        } else {
            //中间插入，保留插入位置的节点
            succ = node(index); 
            pred = succ.prev;
        }

        for (Object o : a) {
            @SuppressWarnings(&quot;unchecked&quot;) E e = (E) o;
            Node&amp;lt;E&amp;gt; newNode = new Node&amp;lt;&amp;gt;(pred, e, null);
            if (pred == null) 
                //前置节点为null,相当于插入链表头
                first = newNode;
            else
                //不为空，则从插入位置之后插入
                pred.next = newNode;
            pred = newNode;
        }
        //插入完成后，判断插入位置succ
        if (succ == null) {
            //succ为null,代表末尾插入
            last = pred;
        } else {
            //succ不为null,代表中间插入，设置插入全部数据后的最后一个数据节点后置节点为succ
            pred.next = succ;
            succ.prev = pred;
        }

        size += numNew;
        modCount++;
        return true;
    }
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;h4 id=&quot;clear&quot;&gt;clear()&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;clear()&lt;/strong&gt;:从列表中删除所有元素。&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
10
11
12
13
14
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;public void clear() {
        //将链表中间的节点内容都设置为null
        for (Node&amp;lt;E&amp;gt; x = first; x != null; ) {
            Node&amp;lt;E&amp;gt; next = x.next;
            x.item = null;
            x.next = null;
            x.prev = null;
            x = next;
        }
        //将首位节点和末尾节点设置为null，尺寸设置为0
        first = last = null;
        size = 0;
        modCount++;
    }
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;还有一些其他方法，但都是基于以上方法的逻辑，就不介绍了。&lt;/p&gt;

&lt;h3 id=&quot;arraylist以下代码基于java8&quot;&gt;ArrayList（以下代码基于JAVA8）&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;ArrayList&lt;/strong&gt;是动态数组，底层就是一个数组, 因此按序查找快, 乱序插入, 删除因为涉及到后面元素移位所以性能慢。
首先需要介绍一个&lt;strong&gt;ArrayList&lt;/strong&gt;方法内常用的一个方法&lt;strong&gt;Arrays.copyOf(T[],int)&lt;/strong&gt;，作用是复制数组，在&lt;strong&gt;ArrayList&lt;/strong&gt;初始化，扩容时都会用到，代码如下&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt; //第一个参数是原始数组，第二个是返回数组的长度
 public static &amp;lt;T&amp;gt; T[] copyOf(T[] original, int newLength) {
        return (T[]) copyOf(original, newLength, original.getClass());
 }
 ////第一个参数是原始数组，第二个是返回数组的长度，第三个返回数组的类
 public static &amp;lt;T,U&amp;gt; T[] copyOf(U[] original, int newLength, Class&amp;lt;? extends T[]&amp;gt; newType) {
        @SuppressWarnings(&quot;unchecked&quot;)
        //判断返回数组的类是否是Object,是的话就创建一个Object数组，不是的话就创建一个特定类的数组
        T[] copy = ((Object)newType == (Object)Object[].class)
            ? (T[]) new Object[newLength]
            : (T[]) Array.newInstance(newType.getComponentType(), newLength);
        //将original从第0个下标开始的Math.min(original.length, newLength)的数据拷贝至copy数组的第0个下标
        System.arraycopy(original, 0, copy, 0,
                         Math.min(original.length, newLength));
        return copy;
 }

&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;ArrayList&lt;/strong&gt;的父类接口，以及内部有几个主要的变量，如下：&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
10
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt; public class ArrayList&amp;lt;E&amp;gt; extends AbstractList&amp;lt;E&amp;gt;
        implements List&amp;lt;E&amp;gt;, RandomAccess, Cloneable, java.io.Serializable
    
 private static final int DEFAULT_CAPACITY = 10;//默认初始容量
 private static final Object[] EMPTY_ELEMENTDATA = {};//用于空实例的共享空数组实例。
 private static final Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = {};
transient Object[] elementData;//存储数组列表元素的数组缓冲区。
private int size;//实际元素个数

 private static final int MAX_ARRAY_SIZE = Integer.MAX_VALUE - 8;//要分配的数组的最大大小，超出的话可能会导致OutOfMemoryError
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;EMPTY_ELEMENTDATA&lt;/strong&gt;和&lt;strong&gt;DEFAULTCAPACITY_EMPTY_ELEMENTDATA&lt;/strong&gt;都是空数组，区别主要是为了判断是使用了哪种构造函数，无参构造创建时使用的是&lt;strong&gt;DEFAULTCAPACITY_EMPTY_ELEMENTDATA&lt;/strong&gt;，有参构造创建时，当&lt;strong&gt;initialCapacity == 0&lt;/strong&gt;使用的是&lt;strong&gt;EMPTY_ELEMENTDATA&lt;/strong&gt;。以便确认如何扩容(下面会分析)。&lt;/p&gt;

&lt;p&gt;&lt;em&gt;注：RandmoAccess接口，即提供了随机访问功能。&lt;/em&gt;&lt;/p&gt;
&lt;h3 id=&quot;构造方法-1&quot;&gt;构造方法&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;构造方法&lt;/strong&gt;:&lt;strong&gt;ArrayList&lt;/strong&gt;构造方法分为三个：&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;//置为DEFAULTCAPACITY_EMPTY_ELEMENTDATA的空列表，之后会在第一次添加元素时扩容成10容量。
public ArrayList() {
        this.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;
    }
    
public ArrayList(int initialCapacity) {
        if (initialCapacity &amp;gt; 0) {
            this.elementData = new Object[initialCapacity];
        } else if (initialCapacity == 0) {
            this.elementData = EMPTY_ELEMENTDATA;
        } else {
            throw new IllegalArgumentException(&quot;Illegal Capacity: &quot;+
                                               initialCapacity);
        }
    }
/**
*   按照集合的迭代器返回元素的顺序构造一个包含指定集合元素的列表。
*/
 public ArrayList(Collection&amp;lt;? extends E&amp;gt; c) {
        //将集合转成数组直接赋值给elementData
        elementData = c.toArray();
        if ((size = elementData.length) != 0) {
            // c.toArray might (incorrectly) not return Object[] (see 6260652)
            if (elementData.getClass() != Object[].class)
                elementData = Arrays.copyOf(elementData, size, Object[].class);
        } else {
            // replace with empty array.
            this.elementData = EMPTY_ELEMENTDATA;
        }
    }
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;ul&gt;
  &lt;li&gt;空参构造方法：将&lt;strong&gt;elementData&lt;/strong&gt;设置为&lt;strong&gt;DEFAULTCAPACITY_EMPTY_ELEMENTDATA&lt;/strong&gt;，最后会初始化成一个容量为10的空数组；&lt;/li&gt;
  &lt;li&gt;带&lt;strong&gt;int&lt;/strong&gt;参数的构造方法：将&lt;strong&gt;elementData&lt;/strong&gt;实例化成传入的初始容量大小的数组，若传入的值为0，则将&lt;strong&gt;elementData&lt;/strong&gt;设置为&lt;strong&gt;EMPTY_ELEMENTDATA&lt;/strong&gt;；&lt;/li&gt;
  &lt;li&gt;带&lt;strong&gt;Collection&lt;/strong&gt;参数的构造方法：按照传入的集合构造一个包含指定元素的列表，r将集合转成数组直接赋值给&lt;strong&gt;elementData&lt;/strong&gt;，将元素个数赋值给&lt;strong&gt;size&lt;/strong&gt;，若元素个数不为0，最后将&lt;strong&gt;elementData&lt;/strong&gt;转换成Object[]类的数组，若元素个数为0，则将&lt;strong&gt;elementData&lt;/strong&gt;置为&lt;strong&gt;EMPTY_ELEMENTDATA&lt;/strong&gt;；&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;总的来说：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;无参构造:&lt;strong&gt;elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA&lt;/strong&gt;;&lt;/li&gt;
  &lt;li&gt;有参构造:&lt;/li&gt;
  &lt;li&gt;
    &lt;ul&gt;
      &lt;li&gt;&lt;strong&gt;initialCapacity==0, elementData = EMPTY_ELEMENTDATA&lt;/strong&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;ul&gt;
      &lt;li&gt;&lt;strong&gt;initialCapacity &amp;gt; 0, elementData = new Object[initialCapacity];&lt;/strong&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;以下是使用时的常用方法实现代码以及分析:&lt;/p&gt;
&lt;h4 id=&quot;addeaddinte&quot;&gt;add(E)/add(int,E)&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;add(E)&lt;/strong&gt;:将指定的元素添加到列表的末尾，调用过程如下。&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt; public boolean add(E e) {
        //判断增加一个元素后的容量是否超出当前数组容量，超过扩容，不超过则不变
        ensureCapacityInternal(size + 1);  // Increments modCount!!
        //将当前数组最后一个数据后的位置赋值为e
        elementData[size++] = e;
        return true;
 }
    
    private void ensureCapacityInternal(int minCapacity) {
        //判断当前elementData是否等于DEFAULTCAPACITY_EMPTY_ELEMENTDATA
        if (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) {
            //将所需大小设置成DEFAULT_CAPACITY(10)和minCapacity中比较大的值
            minCapacity = Math.max(DEFAULT_CAPACITY, minCapacity);
        }

        ensureExplicitCapacity(minCapacity);
    }
    
        private void ensureExplicitCapacity(int minCapacity) {
            modCount++;
        
            // 如果所需的最小容量大于当前elementData的长度
            if (minCapacity - elementData.length &amp;gt; 0)
            grow(minCapacity);
        }
        
    //根据minCapacity(需要的最小容量)扩容
    private void grow(int minCapacity) {
        // overflow-conscious code
        int oldCapacity = elementData.length;//获得当前数组长度
        int newCapacity = oldCapacity + (oldCapacity &amp;gt;&amp;gt; 1);//新容量为原容量的1.5倍
        if (newCapacity - minCapacity &amp;lt; 0) 
            //如果新容量仍小于所需最小容量，直接将新容量置为需要的最小容量
            newCapacity = minCapacity;  
        if (newCapacity - MAX_ARRAY_SIZE &amp;gt; 0)
            //判断当前容量是否超出可分配的最大容量，超出则设置新容量为
            //Integer.MAX_VALUE，保证数组容量不超过Integer.MAX_VALUE
            newCapacity = hugeCapacity(minCapacity);
            
        //根据新容量创建新的数组赋值给elementData，此时minCapacity通常接近size
        elementData = Arrays.copyOf(elementData, newCapacity);
    }
    
    private static int hugeCapacity(int minCapacity) {
        if (minCapacity &amp;lt; 0) // overflow
            throw new OutOfMemoryError();
        //Integer.MAX_VALUE = MAX_ARRAY_SIZE + 8;
        return (minCapacity &amp;gt; MAX_ARRAY_SIZE) ?
            Integer.MAX_VALUE :
            MAX_ARRAY_SIZE;
    }
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;add(int,E)&lt;/strong&gt;:在列表中的指定位置插入指定的元素。将当前位于该位置的元素(如果有的话)和随后的元素向右移动(下标加1)。&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
10
11
12
13
14
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt; public void add(int index, E element) {
        //插入位置超过当前数据尺寸或者插入位置小于0
        if (index &amp;gt; size || index &amp;lt; 0)
            throw new IndexOutOfBoundsException(outOfBoundsMsg(index));
        
        //判断插入数据后的数据是否超出数组范围，超出则扩容，不超出则不变
        ensureCapacityInternal(size + 1);  // Increments modCount!!
        //将elementData数组从index以及之后的数据拷贝至index+1的位置
        //相当于腾出index这个下标的位置，用于存放插入的数据element
        System.arraycopy(elementData, index, elementData, index + 1,
                         size - index);
        elementData[index] = element;
        size++;
    }
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;h4 id=&quot;removeint-1&quot;&gt;remove(int)&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;remove(int):&lt;/strong&gt;:删除列表中指定位置的元素。将所有后续元素向左移动(从它们的下标减去1)。&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt; public E remove(int index) {
        //判断是否超出范围
        if (index &amp;gt;= size)
            throw new IndexOutOfBoundsException(outOfBoundsMsg(index));

        modCount++;
        //获得删除位置的数据
        E oldValue = (E) elementData[index];
        
        //删除后需要移动的数据数量。
        //例共10个数据，删除第5个数据(下标index = 4)，
        //那么需要移动的数据是第五个数据后的数据。也就是10- 4 -1 =5 个数据
        int numMoved = size - index - 1;
        
        //需要移动的数据大于0
        if (numMoved &amp;gt; 0)
            //将elementData数组的第index+1位置开始的numMoved个数据复制到index(即数据往前移一位)
            System.arraycopy(elementData, index+1, elementData, index,
                             numMoved);
                            
        //最后一个数据置为null，同时size-1; 
        elementData[--size] = null; // clear to let GC do its work
        //返回删除的数据
        return oldValue;
    }
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;h4 id=&quot;gete&quot;&gt;get(E)&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;get(E)&lt;/strong&gt;:返回列表中指定位置的元素。&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt; public E get(int index) {
        if (index &amp;gt;= size)
            throw new IndexOutOfBoundsException(outOfBoundsMsg(index));
        
        return (E) elementData[index];
    }
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;h4 id=&quot;setinte-1&quot;&gt;set(int,E)&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;set(int,E)&lt;/strong&gt;:用指定的元素替换列表中指定位置的元素。&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;public E set(int index, E element) {
        if (index &amp;gt;= size)
            throw new IndexOutOfBoundsException(outOfBoundsMsg(index));

        E oldValue = (E) elementData[index];
        elementData[index] = element;
        return oldValue;
    }
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;h4 id=&quot;addallcollection-extends-eaddallint--collection-extends-e-1&quot;&gt;addAll(Collection&amp;lt;? extends E&amp;gt;)/addAll(int , Collection&amp;lt;? extends E&amp;gt;)&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;addAll(Collection&amp;lt;? extends E&amp;gt;)&lt;/strong&gt;:将指定集合中的所有元素追加到末尾&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
10
11
12
13
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt; public boolean addAll(Collection&amp;lt;? extends E&amp;gt; c) {
        //将集合转成数组，并获取数组长度
        Object[] a = c.toArray();
        int numNew = a.length;
        
        //判断追加后元素是否会超出数组范围，超出则扩容
        ensureCapacityInternal(size + numNew);  // Increments modCount
        //将追加数组a从0开始numNew(所有)数据拷贝至elementData的size下标后
        System.arraycopy(a, 0, elementData, size, numNew);
        size += numNew;
        //返回追加数组数据是否有数据
        return numNew != 0;
    }
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;addAll(int , Collection&amp;lt;? extends E&amp;gt;)&lt;/strong&gt;:将指定集合中的所有元素插入到此列表中，从指定位置开始。&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;public boolean addAll(int index, Collection&amp;lt;? extends E&amp;gt; c) {
        if (index &amp;gt; size || index &amp;lt; 0)
            throw new IndexOutOfBoundsException(outOfBoundsMsg(index));
        //将集合转成数组，并获取数组长度
        Object[] a = c.toArray();
        int numNew = a.length;
        //判断插入后元素是否会超出数组范围，超出则扩容
        ensureCapacityInternal(size + numNew);  // Increments modCount
        
        //插入数据后需要移动的数据量
        int numMoved = size - index;
        if (numMoved &amp;gt; 0)
            //将elementData数组的第index位置开始的numMoved个数据复制到index+numNew(即数据往后移numNew位)，腾出numNew个位置存放插入元素
            System.arraycopy(elementData, index, elementData, index + numNew,
                             numMoved);
        //将a数组的数据复制至elementData刚才腾出的位置
        System.arraycopy(a, 0, elementData, index, numNew);
        size += numNew;
        return numNew != 0;
    }
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;h4 id=&quot;clear-1&quot;&gt;clear()&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;clear()&lt;/strong&gt;:从列表中删除所有元素。&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt; public void clear() {
        modCount++;

        // clear to let GC do its work
        for (int i = 0; i &amp;lt; size; i++)
            elementData[i] = null;

        size = 0;
    }
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;ArrayList&lt;/strong&gt;内部还有一个用于分页查看的&lt;strong&gt;SubList&lt;/strong&gt;的内部类，在&lt;strong&gt;subList(int,int)&lt;/strong&gt;内部会调用，作用是返回一个List集合的其中一部分视图。本质也是对&lt;strong&gt;elementData&lt;/strong&gt;这个数组进行操作，这里就不展开。&lt;/p&gt;

&lt;p&gt;&lt;em&gt;注：在无参初始化ArrayList时，Java7是直接初始化10大小的数组，而JAVA8是初始化空数组，在第一次扩容时才按照10进行扩容&lt;/em&gt;&lt;/p&gt;
&lt;h3 id=&quot;vector&quot;&gt;Vector&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;Vector&lt;/strong&gt;是矢量队列，与&lt;strong&gt;ArrayList&lt;/strong&gt;不同，&lt;strong&gt;Vector&lt;/strong&gt;中的操作是&lt;strong&gt;线程安全&lt;/strong&gt;的。
&lt;strong&gt;Vector&lt;/strong&gt;的父类接口，以及内部有几个主要的变量，如下：&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;public class Vector&amp;lt;E&amp;gt;
    extends AbstractList&amp;lt;E&amp;gt;
    implements List&amp;lt;E&amp;gt;, RandomAccess, Cloneable, java.io.Serializable
    
    protected Object[] elementData;//存储矢量组件的数组缓冲区。
    protected int elementCount;//实际元素个数
    protected int capacityIncrement;//capacityIncrement是每次Vector容量增加时的增量值，如果&amp;lt;=0，则每次扩容时容量翻倍，否则就扩容后容量就只是容量+增量。
    private static final int MAX_ARRAY_SIZE = Integer.MAX_VALUE - 8;//要分配的数组的最大大小，超出的话可能会导致OutOfMemoryError
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;h4 id=&quot;构造方法-2&quot;&gt;构造方法&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;构造方法&lt;/strong&gt;:&lt;strong&gt;Vector&lt;/strong&gt;构造方法分为三个：&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt; public Vector() {
        //初始化容量为10
        this(10);
    }
    
 public Vector(int initialCapacity) {
        //初始化增量为0
        this(initialCapacity, 0);
    }
    
 public Vector(int initialCapacity, int capacityIncrement) {
        super();
        if (initialCapacity &amp;lt; 0)
            throw new IllegalArgumentException(&quot;Illegal Capacity: &quot;+
                                               initialCapacity);
        this.elementData = new Object[initialCapacity];
        this.capacityIncrement = capacityIncrement;
    }
    
 public Vector(Collection&amp;lt;? extends E&amp;gt; c) {
        elementData = c.toArray();
        elementCount = elementData.length;
        // c.toArray might (incorrectly) not return Object[] (see 6260652)
        if (elementData.getClass() != Object[].class)
            elementData = Arrays.copyOf(elementData, elementCount, Object[].class);
    }
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;前三个构造方法本质是调用一个方法：初始化一个特定容量的数组，初始化特定增量值，具体的初始化参数看源码；&lt;/p&gt;

&lt;p&gt;带&lt;strong&gt;Collection&lt;/strong&gt;参数的构造方法：按照传入的集合构造一个包含指定元素的列表，r将集合转成数组直接赋值给&lt;strong&gt;elementData&lt;/strong&gt;，将元素个数赋值给&lt;strong&gt;elementCount&lt;/strong&gt;，最后将&lt;strong&gt;elementData&lt;/strong&gt;转换成Object[]类的数组；&lt;/p&gt;
&lt;h4 id=&quot;addeaddinte-1&quot;&gt;add(E)/add(int,E)&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;add(E)&lt;/strong&gt;:将指定的元素添加到Vector的末尾。&lt;strong&gt;synchronized&lt;/strong&gt;方法，线程安全。&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;  public synchronized boolean add(E e) {
        modCount++;
        //容量判断，容量不够则扩容，不然则不变
        ensureCapacityHelper(elementCount + 1);
        elementData[elementCount++] = e;
        return true;
    }
    
  private void ensureCapacityHelper(int minCapacity) {
        // overflow-conscious code
        if (minCapacity - elementData.length &amp;gt; 0)
            grow(minCapacity);
    }
    
  private void grow(int minCapacity) {
        // overflow-conscious code
        int oldCapacity = elementData.length;
        //如果设定的capacityIncrement增量大于0，则新容量为旧容量+增量，否则为双倍旧容量
        int newCapacity = oldCapacity + ((capacityIncrement &amp;gt; 0) ?
                                         capacityIncrement : oldCapacity);
        //判断新容量是否大于所需的最小容量，小于则新容量改为minCapacity
        if (newCapacity - minCapacity &amp;lt; 0)
            newCapacity = minCapacity;
        //判断新容量是否超出
        if (newCapacity - MAX_ARRAY_SIZE &amp;gt; 0)
            //判断当前容量是否超出可分配的最大容量，超出则设置新容量为
            //Integer.MAX_VALUE，保证数组容量不超过Integer.MAX_VALUE
            newCapacity = hugeCapacity(minCapacity);
        elementData = Arrays.copyOf(elementData, newCapacity);
    }
    
  private static int hugeCapacity(int minCapacity) {
        if (minCapacity &amp;lt; 0) // overflow
            throw new OutOfMemoryError();
        return (minCapacity &amp;gt; MAX_ARRAY_SIZE) ?
            Integer.MAX_VALUE :
            MAX_ARRAY_SIZE;
    }
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;add(int,E)&lt;/strong&gt;：在Vector的指定位置插入指定元素。该方法内部调用的方法有&lt;strong&gt;synchronized&lt;/strong&gt;，所以也是线程安全的。&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt; public void add(int index, E element) {
        insertElementAt(element, index);
    }
 /**
  * 在指定的{@code index}处将指定的对象作为这个向量中的组件插入。
  *这个向量中的每个索引值大于或等于指定的{@code index}的组件向上移动，使其索引值比之前的值大1。
  */
 public synchronized void insertElementAt(E obj, int index) {
        modCount++;
        //判断插入位置是否超出范围
        if (index &amp;gt; elementCount) {
            throw new ArrayIndexOutOfBoundsException(index
                                                     + &quot; &amp;gt; &quot; + elementCount);
        }
        //容量判断，容量不够则扩容，不然则不变
        ensureCapacityHelper(elementCount + 1);
        //腾出数组中index下标位置
        System.arraycopy(elementData, index, elementData, index + 1, elementCount - index);
        //将obj插入这个位置
        elementData[index] = obj;
        elementCount++;
    }
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;h4 id=&quot;removeint-2&quot;&gt;remove(int)&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;remove(int)&lt;/strong&gt;:移除Vector中指定位置的元素。线程安全&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt; public synchronized E remove(int index) {
        modCount++;
        if (index &amp;gt;= elementCount)
            throw new ArrayIndexOutOfBoundsException(index);
        E oldValue = elementData(index);
        
        //numMoved需要移动的数据数量
        int numMoved = elementCount - index - 1;
        if (numMoved &amp;gt; 0)
            System.arraycopy(elementData, index+1, elementData, index,
                             numMoved);
        elementData[--elementCount] = null; // Let gc do its work

        return oldValue;
    }

&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;h4 id=&quot;gete-1&quot;&gt;get(E)&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;get(E)&lt;/strong&gt;:返回该Vector中指定位置的元素。线程安全&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt; public synchronized E get(int index) {
        if (index &amp;gt;= elementCount)
            throw new ArrayIndexOutOfBoundsException(index);

        return elementData(index);
    }
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;h4 id=&quot;setinte-2&quot;&gt;set(int,E)&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;set(int,E)&lt;/strong&gt;:用指定的元素替换Vector中指定位置的元素。&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt; public synchronized E set(int index, E element) {
        if (index &amp;gt;= elementCount)
            throw new ArrayIndexOutOfBoundsException(index);

        E oldValue = elementData(index);
        elementData[index] = element;
        return oldValue;
    }
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;h4 id=&quot;addallcollection-extends-eaddallint--collection-extends-e-2&quot;&gt;addAll(Collection&amp;lt;? extends E&amp;gt;)/addAll(int , Collection&amp;lt;? extends E&amp;gt;)&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;addAll(Collection&amp;lt;? extends E&amp;gt;)&lt;/strong&gt;：将指定集合中的所有元素追加到末尾，线程安全&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
10
11
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt; public synchronized boolean addAll(Collection&amp;lt;? extends E&amp;gt; c) {
        modCount++;
        Object[] a = c.toArray();
        int numNew = a.length;
        //判断容量
        ensureCapacityHelper(elementCount + numNew);
        //拷贝数据
        System.arraycopy(a, 0, elementData, elementCount, numNew);
        elementCount += numNew;
        return numNew != 0;
    }
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;addAll(int , Collection&amp;lt;? extends E&amp;gt;)&lt;/strong&gt;:将指定集合中的所有元素插入到Vector的指定位置。线程安全&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;  public synchronized boolean addAll(int index, Collection&amp;lt;? extends E&amp;gt; c) {
        modCount++;
        if (index &amp;lt; 0 || index &amp;gt; elementCount)
            throw new ArrayIndexOutOfBoundsException(index);

        Object[] a = c.toArray();
        int numNew = a.length;
        //判断容量
        ensureCapacityHelper(elementCount + numNew);
        //计算需要移动的元素数量
        int numMoved = elementCount - index;
        if (numMoved &amp;gt; 0)
            //移动数据，腾出numNew个位置
            System.arraycopy(elementData, index, elementData, index + numNew,
                             numMoved);
        //拷贝数据至腾出的位置
        System.arraycopy(a, 0, elementData, index, numNew);
        elementCount += numNew;
        return numNew != 0;
    }
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;h4 id=&quot;clear-2&quot;&gt;clear();&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;clear()&lt;/strong&gt;:从Vector中删除所有元素。线程安全&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
10
11
12
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt; public void clear() {
        removeAllElements();
    }
    
 public synchronized void removeAllElements() {
        modCount++;
        // Let gc do its work
        for (int i = 0; i &amp;lt; elementCount; i++)
            elementData[i] = null;

        elementCount = 0;
    }
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;从代码可以得知，其实&lt;strong&gt;Vector&lt;/strong&gt;就是线程安全的&lt;strong&gt;ArrayList&lt;/strong&gt;，方法内的代码逻辑基本一致，就是多增加了&lt;strong&gt;synchronized&lt;/strong&gt;关键字。同时因为&lt;strong&gt;Vector&lt;/strong&gt;是同步的，当一个&lt;strong&gt;Iterator&lt;/strong&gt;被创建而且正在被使用，另一个线程改变了&lt;strong&gt;Vector&lt;/strong&gt;的状态（例如，添加或删除了一些元素），这时调用&lt;strong&gt;Iterator&lt;/strong&gt;的方法时将抛出&lt;strong&gt;ConcurrentModificationException&lt;/strong&gt;，因此必须捕获该异常。&lt;/p&gt;
&lt;h3 id=&quot;stack&quot;&gt;Stack&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;Stack&lt;/strong&gt;继承自&lt;strong&gt;Vector&lt;/strong&gt;，实现一个&lt;strong&gt;后进先出&lt;/strong&gt;的堆栈。&lt;strong&gt;Stack&lt;/strong&gt;提供5个额外的方法使得&lt;strong&gt;Vector&lt;/strong&gt;得以被当作堆栈使用。基本的&lt;strong&gt;push&lt;/strong&gt;和&lt;strong&gt;pop&lt;/strong&gt;方法，还有&lt;strong&gt;peek&lt;/strong&gt;方法得到栈顶的元素，&lt;strong&gt;empty&lt;/strong&gt;方法测试堆栈是否为空，&lt;strong&gt;search&lt;/strong&gt;方法检测一个元素在堆栈中的位置。&lt;strong&gt;Stack&lt;/strong&gt;刚创建后是空栈。&lt;/p&gt;
&lt;h4 id=&quot;构造方法-3&quot;&gt;构造方法&lt;/h4&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt; //创建一个空堆栈。
 public Stack() {
    }
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;h4 id=&quot;pushe&quot;&gt;push(E)&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;push(E)&lt;/strong&gt;:将E推到堆栈的顶部.&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
10
11
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt; public E push(E item) {
        addElement(item);

        return item;
    }
 //Vector的方法
 public synchronized void addElement(E obj) {
        modCount++;
        ensureCapacityHelper(elementCount + 1);
        elementData[elementCount++] = obj;
    }
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;h4 id=&quot;peek&quot;&gt;peek()&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;peek()&lt;/strong&gt;:查看堆栈顶部的对象，而不将其从堆栈中移除。&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt; public synchronized E peek() {
        int     len = size();

        if (len == 0)
            throw new EmptyStackException();
        return elementAt(len - 1);
    }
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;h4 id=&quot;pop&quot;&gt;pop()&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;pop()&lt;/strong&gt;:删除堆栈顶部的对象，并将该对象作为函数的值返回。&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;     public synchronized E pop() {
        E       obj;
        int     len = size();

        obj = peek();
        removeElementAt(len - 1);

        return obj;
    }
    
    //Vector中的方法，移除指定位置的元素，并将之后的数据向前移动一位
    public synchronized void removeElementAt(int index) {
        modCount++;
        if (index &amp;gt;= elementCount) {
            throw new ArrayIndexOutOfBoundsException(index + &quot; &amp;gt;= &quot; +
                                                     elementCount);
        }
        else if (index &amp;lt; 0) {
            throw new ArrayIndexOutOfBoundsException(index);
        }
        int j = elementCount - index - 1;
        if (j &amp;gt; 0) {
            System.arraycopy(elementData, index + 1, elementData, index, j);
        }
        elementCount--;
        elementData[elementCount] = null; /* to let gc do its work */
    }
    
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;h4 id=&quot;empty&quot;&gt;empty()&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;empty()&lt;/strong&gt;:查看此堆栈是否为空。本质是看数据size是否为0&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt; public boolean empty() {
        return size() == 0;
    }
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;h4 id=&quot;searchobject&quot;&gt;search(Object)&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;search(Object)&lt;/strong&gt;:返回对象在堆栈中的基于1(即栈顶)的位置。&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;public synchronized int search(Object o) {
        int i = lastIndexOf(o);
        
        
        if (i &amp;gt;= 0) {
            return size() - i;
        }
        return -1;
    }
//Vector中的方法,返回Vector中指定元素最后一次出现的索引，如果vector中不包含该元素，则返回-1。
public synchronized int lastIndexOf(Object o) {
        return lastIndexOf(o, elementCount-1);
    }
//Vector中的方法,从index往回搜索值等于o的元素，返回Vector中指定元素最后一次出现的索引，如果没有找到该元素则返回-1。
public synchronized int lastIndexOf(Object o, int index) {
        if (index &amp;gt;= elementCount)
            throw new IndexOutOfBoundsException(index + &quot; &amp;gt;= &quot;+ elementCount);

        if (o == null) {
            for (int i = index; i &amp;gt;= 0; i--)
                if (elementData[i]==null)
                    return i;
        } else {
            for (int i = index; i &amp;gt;= 0; i--)
                if (o.equals(elementData[i]))
                    return i;
        }
        return -1;
    }
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;set&quot;&gt;Set&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;Set&lt;/strong&gt;是一种不包含重复的元素的&lt;strong&gt;Collection&lt;/strong&gt;，即任意的两个元素e1和e2都有e1.equals(e2)=false，&lt;strong&gt;Set&lt;/strong&gt;最多有一个&lt;strong&gt;null&lt;/strong&gt;元素。&lt;/p&gt;
&lt;h3 id=&quot;hashset&quot;&gt;HashSet&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;HashSet&lt;/strong&gt;这个类实现了&lt;strong&gt;Set&lt;/strong&gt;集合，实际内部是使用&lt;strong&gt;HashMap&lt;/strong&gt;的实例。&lt;strong&gt;HashSet&lt;/strong&gt;中对重复元素的理解：和通常意义上的理解不太一样！
两个元素（对象）的&lt;strong&gt;hashCode&lt;/strong&gt;返回值相同，并且&lt;strong&gt;equals&lt;/strong&gt;返回值为&lt;strong&gt;true&lt;/strong&gt;时（或者&lt;strong&gt;地址&lt;/strong&gt;相同时），才称这两个元素是相同的。
&lt;strong&gt;HashSet&lt;/strong&gt;的父类接口，以及内部有几个主要的变量，如下：&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;public class HashSet&amp;lt;E&amp;gt;
    extends AbstractSet&amp;lt;E&amp;gt;
    implements Set&amp;lt;E&amp;gt;, Cloneable, java.io.Serializable
    
    private transient HashMap&amp;lt;E,Object&amp;gt; map;
    //HashMap每个键值对应的value
    private static final Object PRESENT = new Object();
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;可以看到&lt;strong&gt;HashSet&lt;/strong&gt;内部其实是由&lt;strong&gt;HashMap&lt;/strong&gt;组成，&lt;strong&gt;HashMap&lt;/strong&gt;是一种存储键值对的哈希表.&lt;/p&gt;
&lt;h4 id=&quot;构造方法-4&quot;&gt;构造方法&lt;/h4&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt; //构造一个新的空集合;支持HashMap实例具有默认初始容量(16)和负载系数(0.75)。
 public HashSet() {
        map = new HashMap&amp;lt;&amp;gt;();
    }
 //构造一个包含指定元素的的新集合;创建的HashMap实例具有默认初始容量(16和c.size()/.75f(后者约为c.size()的1.3倍)两者中的最大值)和负载系数(0.75)。
 public HashSet(Collection&amp;lt;? extends E&amp;gt; c) {
        map = new HashMap&amp;lt;&amp;gt;(Math.max((int) (c.size()/.75f) + 1, 16));
        addAll(c);
    }
 //构造一个新的空集合;内部构造指定初始容量的HashMap实例
 public HashSet(int initialCapacity) {
        map = new HashMap&amp;lt;&amp;gt;(initialCapacity);
    }
    
 //构造一个新的空集合;内部构造指定初始容量和指定负载系数的HashMap实例
 public HashSet(int initialCapacity, float loadFactor) {
        map = new HashMap&amp;lt;&amp;gt;(initialCapacity, loadFactor);
    }

 //构造一个新的、空的链接哈希集。(这个包的私有构造函数仅由LinkedHashSet使用。)后备HashMap实例是具有指定初始容量和指定负载系数的LinkedHashMap。 
 HashSet(int initialCapacity, float loadFactor, boolean dummy) {
        map = new LinkedHashMap&amp;lt;&amp;gt;(initialCapacity, loadFactor);
    }
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;h4 id=&quot;addeaddinte-2&quot;&gt;add(E)/add(int,E)&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;add(E)&lt;/strong&gt;:如果E还不存在的话，将指定的元素添加到这个集合中。如果存在，则值不变直接返回false;&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;  public boolean add(E e) {
        return map.put(e, PRESENT)==null;
    }
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;代码可以看出&lt;/p&gt;
&lt;h4 id=&quot;removeint如果指定的元素存在则从集合中移除该元素返回集合中是否包含此元素&quot;&gt;remove(int):如果指定的元素存在，则从集合中移除该元素。返回集合中是否包含此元素。&lt;/h4&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;   public boolean remove(Object o) {
        return map.remove(o)==PRESENT;
    }
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;h4 id=&quot;containsobject&quot;&gt;contains(Object)&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;contains(Object)&lt;/strong&gt;:返回&lt;strong&gt;HashSet&lt;/strong&gt;中是否包含此元素&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;  public boolean contains(Object o) {
        return map.containsKey(o);
    }
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;h4 id=&quot;clear-3&quot;&gt;clear()&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;clear()&lt;/strong&gt;:从集合中删除所有元素。&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt; public void clear() {
        map.clear();
    }
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;h4 id=&quot;总结&quot;&gt;总结&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;HashSet&lt;/strong&gt;基本所有方法都是直接调用&lt;strong&gt;HashMap&lt;/strong&gt;的方法，为了保证数据不重复，采用了存储时用&lt;strong&gt;key&lt;/strong&gt;存储的方法，再&lt;strong&gt;HashMap&lt;/strong&gt;中,&lt;strong&gt;key&lt;/strong&gt;是不重复的，所以&lt;strong&gt;HashSet&lt;/strong&gt;就不会有存储重复的数据了。
&lt;em&gt;HashSet是线程不同步的&lt;/em&gt;&lt;/p&gt;
&lt;h3 id=&quot;treeset&quot;&gt;TreeSet&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;TreeSet&lt;/strong&gt;是一个有序的集合，它的作用是提供有序的Set集合。&lt;strong&gt;TreeSet&lt;/strong&gt;的元素支持2种排序方式：自然排序或者根据提供的Comparator进行排序。&lt;/p&gt;
</description>
        <pubDate>Wed, 30 Dec 2020 16:35:00 +0800</pubDate>
        <link>https://yuhanchen5027.github.io//article/2020/12/30/JAVA%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%86%85%E9%83%A8%E5%8F%8A%E5%9F%BA%E7%A1%80%E6%96%B9%E6%B3%95%E5%AE%9E%E7%8E%B0%E4%BA%8C-Collection/</link>
        <guid isPermaLink="true">https://yuhanchen5027.github.io//article/2020/12/30/JAVA%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%86%85%E9%83%A8%E5%8F%8A%E5%9F%BA%E7%A1%80%E6%96%B9%E6%B3%95%E5%AE%9E%E7%8E%B0%E4%BA%8C-Collection/</guid>
        
        <category>JAVA</category>
        
        <category>数据结构</category>
        
        
        <category>article</category>
        
      </item>
    
      <item>
        <title>JAVA数据结构内部及基础方法实现一（Map）</title>
        <description>&lt;p&gt;JAVA有几种常用的数据结构，主要是继承&lt;strong&gt;Collection&lt;/strong&gt;和&lt;strong&gt;Map&lt;/strong&gt;这两个主要接口的数据实现类&lt;/p&gt;

&lt;p&gt;在jdk1.7和jdk1.8中，实现会有些许不同，之后会在注解中添加两版本区别
下面分别介绍几个常用的数据结构(按照继承的接口分为两类)，以下代码截取自&lt;strong&gt;基于JAVA8的android SDK 28&lt;/strong&gt;&lt;/p&gt;
&lt;h1 id=&quot;map&quot;&gt;Map&lt;/h1&gt;
&lt;p&gt;&lt;strong&gt;Map&lt;/strong&gt;接口提供&lt;strong&gt;key&lt;/strong&gt;到&lt;strong&gt;value&lt;/strong&gt;的映射。一个&lt;strong&gt;Map&lt;/strong&gt;中不能包含相同的&lt;strong&gt;key&lt;/strong&gt;，每个&lt;strong&gt;key&lt;/strong&gt;只能映射一个&lt;strong&gt;value&lt;/strong&gt;。&lt;strong&gt;Map&lt;/strong&gt;接口提供3种集合的视图，&lt;strong&gt;Map&lt;/strong&gt;的内容可以被当作一组&lt;strong&gt;key&lt;/strong&gt;集合，一组&lt;strong&gt;value&lt;/strong&gt;集合，或者一组&lt;strong&gt;key-value&lt;/strong&gt;映射。&lt;/p&gt;

&lt;h2 id=&quot;hashmap以下源码基于java8与java7有较大差别&quot;&gt;HashMap(以下源码基于JAVA8，与JAVA7有较大差别)&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;HashMap&lt;/strong&gt;继承&lt;strong&gt;Map&lt;/strong&gt;接口，实现一个key-value映射的哈希表。是非同步的，同时允许n&lt;strong&gt;ull value&lt;/strong&gt;和&lt;strong&gt;null key&lt;/strong&gt;。
&lt;strong&gt;HashMap&lt;/strong&gt;的父类接口，以及内部有几个主要的变量，如下：&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;public class HashMap&amp;lt;K,V&amp;gt; extends AbstractMap&amp;lt;K,V&amp;gt;
    implements Map&amp;lt;K,V&amp;gt;, Cloneable, Serializable 

//默认的初始容量-必须是2的幂。
static final int DEFAULT_INITIAL_CAPACITY = 1 &amp;lt;&amp;lt; 4; // aka 16
//最大容量，如果两个带参数的构造函数中的任何一个隐式指定了更高的值，则使用该值。一定是2的幂&amp;lt;= 1&amp;lt;&amp;lt;30。
static final int MAXIMUM_CAPACITY = 1 &amp;lt;&amp;lt; 30;
//未设置负载系统时默认的负载系数/加载因子。
static final float DEFAULT_LOAD_FACTOR = 0.75f;
//容器计数阈值,当table对应hash位置的链表元素数量超过这个阈值，该位置的链表会转换为红黑树
static final int TREEIFY_THRESHOLD = 8;
//容器计数阈值,当table对应hash位置的红黑树元素数量小雨这个阈值，该位置的红黑树会转换为单链表
static final int UNTREEIFY_THRESHOLD = 6;

static final int MIN_TREEIFY_CAPACITY = 64;
//存放数据的表，就是HashMap数据基类的数组，在第一次使用时进行初始化，并根据需要调整大小。分配时，长度总是2的幂。
transient Node&amp;lt;K,V&amp;gt;[] table;
//此Map映射中包含的键-值对的数量。
transient int size;
//(threshold = 容量*负载系数/加载因子)扩容阈值，可以说是一个是否需要扩容的判断条件，当HashMap的size&amp;gt;threshold时会进行resize操作。
int threshold;
//负载系数/加载因子，可以说是当前HashMap满的程度，
//假设它等于0.75，那么在HashMap的键值对数量超过容量*0.75时，则会进行扩容。
//保证有足够的空间进行数据存放，同时不会经常进行扩容。
final float loadFactor;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;Node&lt;/strong&gt;:&lt;strong&gt;HashMap&lt;/strong&gt;的数据基类&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;static class Node&amp;lt;K,V&amp;gt; implements Map.Entry&amp;lt;K,V&amp;gt; {
        //hash值
        final int hash;
        final K key;
        V value;
        //下一个对象
        Node&amp;lt;K,V&amp;gt; next;

        Node(int hash, K key, V value, Node&amp;lt;K,V&amp;gt; next) {
            this.hash = hash;
            this.key = key;
            this.value = value;
            this.next = next;
        }

        public final K getKey()        { return key; }
        public final V getValue()      { return value; }
        public final String toString() { return key + &quot;=&quot; + value; }

        public final int hashCode() {
            return Objects.hashCode(key) ^ Objects.hashCode(value);
        }

        public final V setValue(V newValue) {
            V oldValue = value;
            value = newValue;
            return oldValue;
        }

        public final boolean equals(Object o) {
            if (o == this)
                return true;
            if (o instanceof Map.Entry) {
                Map.Entry&amp;lt;?,?&amp;gt; e = (Map.Entry&amp;lt;?,?&amp;gt;)o;
                if (Objects.equals(key, e.getKey()) &amp;amp;&amp;amp;
                    Objects.equals(value, e.getValue()))
                    return true;
            }
            return false;
        }
    }
    
    //JAVA8引入红黑树TreeNode，之后会分析
    static final class TreeNode&amp;lt;K,V&amp;gt; extends LinkedHashMap.LinkedHashMapEntry&amp;lt;K,V&amp;gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;Node&lt;/strong&gt;是一个单链表结构的类，由于&lt;strong&gt;HashMap&lt;/strong&gt;存储健值对时，会先将&lt;strong&gt;key&lt;/strong&gt;转成&lt;strong&gt;hash&lt;/strong&gt;与当前容量-1进行一个与操作( (n - 1) &amp;amp; hash)转换成一个&lt;strong&gt;下标值&lt;/strong&gt;，在数组中对应一个&lt;strong&gt;Node&lt;/strong&gt;，所以会存在转换出来的&lt;strong&gt;下标值&lt;/strong&gt;相同(&lt;strong&gt;哈希冲突&lt;/strong&gt;)，但&lt;strong&gt;key&lt;/strong&gt;不同的情况，所以同一个&lt;strong&gt;下标值&lt;/strong&gt;可能对应不同的健值对。所以table数组采用&lt;strong&gt;Node&lt;/strong&gt;这个单链表的作为存储基类，用于存放这些&lt;strong&gt;下标值&lt;/strong&gt;相同，但键值不同的数据；&lt;/p&gt;

&lt;p&gt;在&lt;strong&gt;JAVA8&lt;/strong&gt;中考虑到如果哈希冲突多的情况，单链表&lt;strong&gt;Node&lt;/strong&gt;的长度会越来越长，此时通过单链表来寻找对应&lt;strong&gt;Key&lt;/strong&gt;对应的&lt;strong&gt;Value&lt;/strong&gt;的时候就会使得时间复杂度达到&lt;strong&gt;O(n)&lt;/strong&gt;，因此在&lt;strong&gt;JAVA8&lt;/strong&gt;中引入了&lt;strong&gt;TreeNode(红黑树)&lt;/strong&gt;，当链表长度超过&lt;strong&gt;TREEIFY_THRESHOLD(8)&lt;/strong&gt;的时候，会将单链表&lt;strong&gt;Node&lt;/strong&gt;转换成红黑树&lt;strong&gt;TreeNode&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;&lt;em&gt;红黑树是一种易于增删改查的二叉树，他对与数据的查询的时间复杂度是O(logn)，所以利用红黑树的特点就可以更高效的对 HashMap 中的元素进行操作。&lt;/em&gt;&lt;/p&gt;
&lt;h4 id=&quot;构造方法&quot;&gt;构造方法&lt;/h4&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
82
83
84
85
86
87
88
89
90
91
92
93
94
95
96
97
98
99
100
101
102
103
104
105
106
107
108
109
110
111
112
113
114
115
116
117
118
119
120
121
122
123
124
125
126
127
128
129
130
131
132
133
134
135
136
137
138
139
140
141
142
143
144
145
146
147
148
149
150
151
152
153
154
155
156
157
158
159
160
161
162
163
164
165
166
167
168
169
170
171
172
173
174
175
176
177
178
179
180
181
182
183
184
185
186
187
188
189
190
191
192
193
194
195
196
197
198
199
200
201
202
203
204
205
206
207
208
209
210
211
212
213
214
215
216
217
218
219
220
221
222
223
224
225
226
227
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;    public HashMap() {
        this.loadFactor = DEFAULT_LOAD_FACTOR; // all other fields defaulted
    }
    //构造一个具有指定的初始容量和默认的负载系数(0.75)的空的HashMap，。
    public HashMap(int initialCapacity) {
        this(initialCapacity, DEFAULT_LOAD_FACTOR);
    }
    
    //构造一个具有指定的初始容量和负载系数的空的HashMap，
    public HashMap(int initialCapacity, float loadFactor) {
        if (initialCapacity &amp;lt; 0)
            throw new IllegalArgumentException(&quot;Illegal initial capacity: &quot; +
                                               initialCapacity);
        if (initialCapacity &amp;gt; MAXIMUM_CAPACITY)
            initialCapacity = MAXIMUM_CAPACITY;
        if (loadFactor &amp;lt;= 0 || Float.isNaN(loadFactor))
            throw new IllegalArgumentException(&quot;Illegal load factor: &quot; +
                                               loadFactor);
        this.loadFactor = loadFactor;
        this.threshold = tableSizeFor(initialCapacity);
    }
    //构造一个与指定的Map相同键值对映射的新的HashMap。该HashMap是用默认的负载系数(0.75)创建的，初始容量足以容纳指定的Map中的映射。
    public HashMap(Map&amp;lt;? extends K, ? extends V&amp;gt; m) {
        this.loadFactor = DEFAULT_LOAD_FACTOR;
        putMapEntries(m, false);
    }
    
    final void putMapEntries(Map&amp;lt;? extends K, ? extends V&amp;gt; m, boolean evict) {
        //得到推入的map大小
        int s = m.size();
        if (s &amp;gt; 0) {
            if (table == null) { // pre-size
                //根据map大小和负载因子计算出设置的容量大小
                float ft = ((float)s / loadFactor) + 1.0F;
                //判断容量是否超出最大容量
                int t = ((ft &amp;lt; (float)MAXIMUM_CAPACITY) ?
                         (int)ft : MAXIMUM_CAPACITY);
                if (t &amp;gt; threshold)
                    threshold = tableSizeFor(t);
            }
            else if (s &amp;gt; threshold)
                resize();
            for (Map.Entry&amp;lt;? extends K, ? extends V&amp;gt; e : m.entrySet()) {
                K key = e.getKey();
                V value = e.getValue();
                putVal(hash(key), key, value, false, evict);
            }
        }
    }
    //tableSizeFor的功能（不考虑大于最大容量的情况）是返回大于输入参数且最近的2的整数次幂的数。比如10，则返回16。
    static final int tableSizeFor(int cap) {
        int n = cap - 1;
        n |= n &amp;gt;&amp;gt;&amp;gt; 1;
        n |= n &amp;gt;&amp;gt;&amp;gt; 2;
        n |= n &amp;gt;&amp;gt;&amp;gt; 4;
        n |= n &amp;gt;&amp;gt;&amp;gt; 8;
        n |= n &amp;gt;&amp;gt;&amp;gt; 16;
        return (n &amp;lt; 0) ? 1 : (n &amp;gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + 1;
    }
    /**********************以下两个方法对于整个HashMap极其重要**********************/
    
    //HashMap添加值的方法
    final V putVal(int hash, K key, V value, boolean onlyIfAbsent,
                   boolean evict) {
        Node&amp;lt;K,V&amp;gt;[] tab; Node&amp;lt;K,V&amp;gt; p; int n, i;
        //判断当前HashMap的table大小
        if ((tab = table) == null || (n = tab.length) == 0)
            //table未创建，调用resize()进行初始化(扩容)
            n = (tab = resize()).length;
            
        //去table中最后一位与hash进行按位与操作，得到的值赋值给i，
        //判断位置的值是否为null，为null则代表还没有与添加数据键值相应的hash相同的数据推入过;
        if ((p = tab[i = (n - 1) &amp;amp; hash]) == null)
            //为空则直接将键值对添加的table的i位置
            tab[i] = newNode(hash, key, value, null);
        else {
            //若不为空，则对应键值hash位置已有数据
            //e代表最后存储的键值对
            Node&amp;lt;K,V&amp;gt; e; K k;
            if (p.hash == hash &amp;amp;&amp;amp;
                ((k = p.key) == key || (key != null &amp;amp;&amp;amp; key.equals(k))))
                //键值hash相同，键值内容也相同，代表将值替换
                e = p;
            else if (p instanceof TreeNode)
                //此时p对应位置的数据量超过TREEIFY_THRESHOLD(8)，Node已转换为TreeNode,所以采用TreeNode的新增节点方式
                e = ((TreeNode&amp;lt;K,V&amp;gt;)p).putTreeVal(this, tab, hash, key, value);
            else {
                //此时p对应位置的数据量未超过TREEIFY_THRESHOLD(8)，所以还没转化成红黑树。仍是一个Node链表
                
                //binCount用于计算当前链表的节点数，binCount从0开始，代表binCount = 节点数+1；
                for (int binCount = 0; ; ++binCount) {
                    //判断是否到了链表的末尾节点
                    if ((e = p.next) == null) {
                        //在链表末尾添加新生成的Node
                        p.next = newNode(hash, key, value, null);
                        //判断当前节数是否超过TREEIFY_THRESHOLD(8)，超过则将链表Node转换成红黑树
                        if (binCount &amp;gt;= TREEIFY_THRESHOLD， - 1) // -1 for 1st
                            treeifyBin(tab, hash);
                        break;
                    }
                    //判断是否存在hash相同，key值相同的键值，存在则跳出循环。
                    if (e.hash == hash &amp;amp;&amp;amp;
                        ((k = e.key) == key || (key != null &amp;amp;&amp;amp; key.equals(k))))
                        break;
                    p = e;
                }
            }
            //e!=null代表map种存在key值相同的键值，将对应的valuet替换成新的，同时返回旧value
            if (e != null) { 
                V oldValue = e.value;
                //onlyIfAbsent调用方法时传入，如果为true，则不会覆盖值
                if (!onlyIfAbsent || oldValue == null)
                    e.value = value;
                afterNodeAccess(e);//一个回调方法
                return oldValue;
            }
        }
        ++modCount;
        //判断是否需要扩容map
        if (++size &amp;gt; threshold)
            resize();
        afterNodeInsertion(evict);//一个回调方法
        return null;
    }
    
    //HashMap的扩容方法
    final Node&amp;lt;K,V&amp;gt;[] resize() {
        //获得当前table
        Node&amp;lt;K,V&amp;gt;[] oldTab = table;
        //获取当前map容量，扩容阈值
        int oldCap = (oldTab == null) ? 0 : oldTab.length;
        int oldThr = threshold;
        int newCap, newThr = 0;
        if (oldCap &amp;gt; 0) {
            if (oldCap &amp;gt;= MAXIMUM_CAPACITY) {
                //当前容量超过了可设的最大值
                threshold = Integer.MAX_VALUE;
                return oldTab;
            }
            else if ((newCap = oldCap &amp;lt;&amp;lt; 1) &amp;lt; MAXIMUM_CAPACITY &amp;amp;&amp;amp;
                     oldCap &amp;gt;= DEFAULT_INITIAL_CAPACITY)
                //容量翻倍后不超过可设最大容量，旧容量超过课设最小容量
                newThr = oldThr &amp;lt;&amp;lt; 1; // 扩容阈值也翻倍
        }
        else if (oldThr &amp;gt; 0) 
            newCap = oldThr;// 此时oldCap《=0,代表hashmap未初始化，但设置了扩容阈值，初始容量设置为阈值
        else {               // 初始扩容阈值为0时
            newCap = DEFAULT_INITIAL_CAPACITY;//初始容量为默认容量(16)
            //初始扩容阈值 = 初始容量(16) * 负载系数/加载因子(0.75)
            newThr = (int)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);
        }
        if (newThr == 0) {
            //上面第二种情况下未计算新的扩容阈值，这里计算并赋值
            float ft = (float)newCap * loadFactor;
            newThr = (newCap &amp;lt; MAXIMUM_CAPACITY &amp;amp;&amp;amp; ft &amp;lt; (float)MAXIMUM_CAPACITY ?
                      (int)ft : Integer.MAX_VALUE);
        }
        threshold = newThr;
        @SuppressWarnings({&quot;rawtypes&quot;,&quot;unchecked&quot;})
        //根据新的容量创建一个新的table
        Node&amp;lt;K,V&amp;gt;[] newTab = (Node&amp;lt;K,V&amp;gt;[])new Node[newCap];
        table = newTab;
        //将之前的数据转移到新的table
        if (oldTab != null) {
            for (int j = 0; j &amp;lt; oldCap; ++j) {
                Node&amp;lt;K,V&amp;gt; e;
                if ((e = oldTab[j]) != null) {
                    oldTab[j] = null;
                    if (e.next == null)
                        //该Node只有一个数据，根据hash和容量重新计算下标放入新table
                        newTab[e.hash &amp;amp; (newCap - 1)] = e;
                    else if (e instanceof TreeNode)
                        //该Node是一个红黑树Node的情况
                        ((TreeNode&amp;lt;K,V&amp;gt;)e).split(this, newTab, j, oldCap);
                    else { 
                        //该Node是一个有多个数据的链表(1&amp;lt;数据数量&amp;lt;TREEIFY_THRESHOLD(8))
                        //loHead是用来保存新链表上的低位区的头元素的，loTail是用来保存低位区的尾元素的，
                        Node&amp;lt;K,V&amp;gt; loHead = null, loTail = null;
                        //hiHead是用来保存新链表上的高位区的头元素的，hiTail是用来保存高位区的尾元素的，
                        Node&amp;lt;K,V&amp;gt; hiHead = null, hiTail = null;
                        Node&amp;lt;K,V&amp;gt; next;
                        //进行链表遍历至末尾节点，这部分可能会将会将当前链表分列成两个链表，取决于hash的位数
                        do {
                            next = e.next;
                            //等于0时，则将该头节点放到新数组时的索引位置等于其在旧数组时的索引位置,记为低位区链表lo开头-low;
                            if ((e.hash &amp;amp; oldCap) == 0) {
                                if (loTail == null)
                                    loHead = e;
                                else
                                    loTail.next = e;
                                loTail = e;
                            }
                            else {//不等于0时,则将该头节点放到新数组时的索引位置等于其在旧数组时的索引位置再加上旧数组长度，记为高位区链表hi开头high.
                                if (hiTail == null)
                                    hiHead = e;
                                else
                                    hiTail.next = e;
                                hiTail = e;
                            }
                            /**
                             * 这部分举个例子比较好理解呢，举个例子来看，假设oldCap = 16 = 10000，两个数据的hash分别为hash1 = 7 = 0111, hash2 = 23 = 10111
                             * 未扩容的时候两个hash对应的下标分别是:
                             * (hash1 &amp;amp; oldCap -1) = 0111 &amp;amp; 01111 = 111
                             * (hash2 &amp;amp; oldCap -1) = 10111 &amp;amp; 01111 = 111 是同样的位置；
                             * 此时我们将容量扩大一倍 newCap = 32 = 100000，在此计算下标
                             * (hash1 &amp;amp; newCap -1) = 0111 &amp;amp; 11111 = 111;位置不变
                             * hash2 &amp;amp; oldCap -1) = 10111 &amp;amp; 11111 = 10111;位置变了，比原来的位置多了10000，即oldCap
                             * 再来算代码中的e.hash &amp;amp; oldCap == 0这部分
                             * 可以知道hash1 &amp;amp; oldCap = 0111 &amp;amp; 10000 = 0；hash2 &amp;amp; oldCap = 10111 &amp;amp; 10000 = 1；
                             * 所以可以得出，如果e.hash &amp;amp; oldCap == 0，那么对应hash的Node在表扩容后也在数组同样的位置
                             * 而e.hash &amp;amp; oldCap != 0的Node，则会移动，移动的间隔就是oldCap的长度
                             */
                        } while ((e = next) != null);
                        if (loTail != null) {
                            loTail.next = null;
                            newTab[j] = loHead;
                        }
                        if (hiTail != null) {
                            hiTail.next = null;
                            newTab[j + oldCap] = hiHead;
                        }
                    }
                }
            }
        }
        return newTab;
    }
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;可以看出其实&lt;strong&gt;HashMap&lt;/strong&gt;初始化时是不会初始化我们的数据表&lt;strong&gt;table&lt;/strong&gt;，只会初始化一些容量大小和负载因子的值，在第一次使用时才会创建，例如在第四个构造函数，根据传入的&lt;strong&gt;map&lt;/strong&gt;构造一个&lt;strong&gt;HashMap&lt;/strong&gt;，调用&lt;strong&gt;putVal&lt;/strong&gt;方法时内部的&lt;strong&gt;resize&lt;/strong&gt;函数会初始化&lt;strong&gt;table&lt;/strong&gt;，当单链表数据项超过&lt;strong&gt;TREEIFY_THRESHOLD(8)&lt;/strong&gt;，会将单链表&lt;strong&gt;Node&lt;/strong&gt;转换成红黑树&lt;strong&gt;TreeNode&lt;/strong&gt;，&lt;strong&gt;TreeNode&lt;/strong&gt;比较复杂，留到最后讲。&lt;/p&gt;

&lt;p&gt;接下来来看一些常用的方法&lt;/p&gt;
&lt;h4 id=&quot;putkv&quot;&gt;put(K,V)&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;put(K,V)&lt;/strong&gt;:推入指定的键值对的映射。如果该映射先前包含了该键的映射，则旧值将被替换。&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;public V put(K key, V value) {
        return putVal(hash(key), key, value, false, true);
    }
    
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;h4 id=&quot;removeobject&quot;&gt;remove(Object)&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;remove(Object)&lt;/strong&gt;:从该映射中移除指定键的映射(如果存在)。&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;public V remove(Object key) {
        Node&amp;lt;K,V&amp;gt; e;
        return (e = removeNode(hash(key), key, null, false, true)) == null ?
            null : e.value;
    }
    
final Node&amp;lt;K,V&amp;gt; removeNode(int hash, Object key, Object value,
                               boolean matchValue, boolean movable) {
        Node&amp;lt;K,V&amp;gt;[] tab; Node&amp;lt;K,V&amp;gt; p; int n, index;
        // 判断table和对应的key值Node是否为空
        if ((tab = table) != null &amp;amp;&amp;amp; (n = tab.length) &amp;gt; 0 &amp;amp;&amp;amp;
            (p = tab[index = (n - 1) &amp;amp; hash]) != null) {
            //node存放键值相同的Node
            Node&amp;lt;K,V&amp;gt; node = null, e; K k; V v;
            if (p.hash == hash &amp;amp;&amp;amp;
                ((k = p.key) == key || (key != null &amp;amp;&amp;amp; key.equals(k))))
                //找到了对应的Node，此处结束node = p;
                node = p;
            else if ((e = p.next) != null) {//当前链表头不是对应的键值对映射
                if (p instanceof TreeNode)
                    // 如果是红黑树TreeNode，则在红黑树内寻找
                    node = ((TreeNode&amp;lt;K,V&amp;gt;)p).getTreeNode(hash, key);
                else {
                    //否则在单链表内循环查找，此处结束node = p.next;
                    do {
                        if (e.hash == hash &amp;amp;&amp;amp;
                            ((k = e.key) == key ||
                             (key != null &amp;amp;&amp;amp; key.equals(k)))) {
                            node = e;
                            break;
                        }
                        p = e;
                    } while ((e = e.next) != null);
                }
            }
            //如果matchValue为true,则只移除value相等的键值对映射
            if (node != null &amp;amp;&amp;amp; (!matchValue || (v = node.value) == value ||
                                 (value != null &amp;amp;&amp;amp; value.equals(v)))) {
                if (node instanceof TreeNode)
                    //调用红黑树的方式移除
                    ((TreeNode&amp;lt;K,V&amp;gt;)node).removeTreeNode(this, tab, movable);
                else if (node == p)
                    //node是单链表头
                    tab[index] = node.next; 
                else
                    //此时node就会从单链表中分离
                    p.next = node.next;
                ++modCount;
                --size;
                afterNodeRemoval(node);
                return node;
            }
        }
        return null;
    }
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;h4 id=&quot;getobject&quot;&gt;get(Object)&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;get(Object)&lt;/strong&gt;:返回指定键映射到的值，如果该映射不包含该键的映射，则返回null。&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt; public V get(Object key) {
        Node&amp;lt;K,V&amp;gt; e;
        return (e = getNode(hash(key), key)) == null ? null : e.value;
    }
    
 final Node&amp;lt;K,V&amp;gt; getNode(int hash, Object key) {
        Node&amp;lt;K,V&amp;gt;[] tab; Node&amp;lt;K,V&amp;gt; first, e; int n; K k;
        //判断table是否为空，是否存在数据，是否存在对应键值的Node
        if ((tab = table) != null &amp;amp;&amp;amp; (n = tab.length) &amp;gt; 0 &amp;amp;&amp;amp;
            (first = tab[(n - 1) &amp;amp; hash]) != null) {
            if (first.hash == hash &amp;amp;&amp;amp; // always check first node
                ((k = first.key) == key || (key != null &amp;amp;&amp;amp; key.equals(k))))
                //单链表头就是对应的Node，直接返回
                return first;
            //在链表内搜索hash和key值相同的Node并返回
            if ((e = first.next) != null) {
                if (first instanceof TreeNode)
                    return ((TreeNode&amp;lt;K,V&amp;gt;)first).getTreeNode(hash, key);
                do {
                    if (e.hash == hash &amp;amp;&amp;amp;
                        ((k = e.key) == key || (key != null &amp;amp;&amp;amp; key.equals(k))))
                        return e;
                } while ((e = e.next) != null);
            }
        }
        return null;
    }
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;h4 id=&quot;putallmap-extends-k--extends-v&quot;&gt;putAll(Map&amp;lt;? extends K, ? extends V&amp;gt;)&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;putAll(Map&amp;lt;? extends K, ? extends V&amp;gt;)&lt;/strong&gt;:将指定Map的所有键值对映射复制到此映射Map。这些映射将替换该映射对指定映射中对应存在的键值对映射。&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt; public void putAll(Map&amp;lt;? extends K, ? extends V&amp;gt; m) {
        putMapEntries(m, true);
    }
    
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;h4 id=&quot;clear&quot;&gt;clear()&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;clear()&lt;/strong&gt;:清空&lt;strong&gt;HashMap&lt;/strong&gt;中的所有键值对映射；&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
10
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt; public void clear() {
        Node&amp;lt;K,V&amp;gt;[] tab;
        modCount++;
        //将table数组每一位都设置为null;
        if ((tab = table) != null &amp;amp;&amp;amp; size &amp;gt; 0) {
            size = 0;
            for (int i = 0; i &amp;lt; tab.length; ++i)
                tab[i] = null;
        }
    }
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;h2 id=&quot;hashtable&quot;&gt;HashTable&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;Hashtable&lt;/strong&gt;继承&lt;strong&gt;Map&lt;/strong&gt;接口，实现一个key-value映射的哈希表。任何非空（&lt;strong&gt;non-null&lt;/strong&gt;）的对象都可作为key或者value。
&lt;strong&gt;HashTable&lt;/strong&gt;的父类接口，以及内部有几个主要的变量，如下：&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;public class Hashtable&amp;lt;K,V&amp;gt;
    extends Dictionary&amp;lt;K,V&amp;gt;
    implements Map&amp;lt;K,V&amp;gt;, Cloneable, java.io.Serializable
//hash数据表
private transient HashtableEntry&amp;lt;?,?&amp;gt;[] table;
//HashTable中的数据数量
private transient int count;
//(threshold = 容量*负载系数/加载因子)扩容阈值，可以说是一个是否需要扩容的判断条件，当HashMap的size&amp;gt;threshold时会进行resize操作。
int threshold;
private int threshold;
//负载系数/加载因子，可以说是当前HashMap满的程度，
//假设它等于0.75，那么在HashMap的键值对数量超过容量*0.75时，则会进行扩容。
//保证有足够的空间进行数据存放，同时不会经常进行扩容。
final float loadFactor;
private float loadFactor;

//可分配的内部数组的最大大小
private static final int MAX_ARRAY_SIZE = Integer.MAX_VALUE - 8;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;HashtableEntry&lt;/strong&gt;:HashTable的数据基类&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt; private static class HashtableEntry&amp;lt;K,V&amp;gt; implements Map.Entry&amp;lt;K,V&amp;gt; {
    // END Android-changed: Renamed Entry -&amp;gt; HashtableEntry.
        final int hash;
        final K key;
        V value;
        HashtableEntry&amp;lt;K,V&amp;gt; next;

        protected HashtableEntry(int hash, K key, V value, HashtableEntry&amp;lt;K,V&amp;gt; next) {
            this.hash = hash;
            this.key =  key;
            this.value = value;
            this.next = next;
        }

        @SuppressWarnings(&quot;unchecked&quot;)
        protected Object clone() {
            return new HashtableEntry&amp;lt;&amp;gt;(hash, key, value,
                                  (next==null ? null : (HashtableEntry&amp;lt;K,V&amp;gt;) next.clone()));
        }

        // Map.Entry Ops

        public K getKey() {
            return key;
        }

        public V getValue() {
            return value;
        }

        public V setValue(V value) {
            if (value == null)
                throw new NullPointerException();

            V oldValue = this.value;
            this.value = value;
            return oldValue;
        }

        public boolean equals(Object o) {
            if (!(o instanceof Map.Entry))
                return false;
            Map.Entry&amp;lt;?,?&amp;gt; e = (Map.Entry&amp;lt;?,?&amp;gt;)o;

            return (key==null ? e.getKey()==null : key.equals(e.getKey())) &amp;amp;&amp;amp;
               (value==null ? e.getValue()==null : value.equals(e.getValue()));
        }

        public int hashCode() {
            return hash ^ Objects.hashCode(value);
        }

        public String toString() {
            return key.toString()+&quot;=&quot;+value.toString();
        }
    }
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;HashTable&lt;/strong&gt;与&lt;strong&gt;HashMap&lt;/strong&gt;非常相似，有很多作用一样的变量。&lt;/p&gt;
&lt;h4 id=&quot;构造方法-1&quot;&gt;构造方法&lt;/h4&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
82
83
84
85
86
87
88
89
90
91
92
93
94
95
96
97
98
99
100
101
102
103
104
105
106
107
108
109
110
111
112
113
114
115
116
117
118
119
120
121
122
123
124
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt; //构造一个新的Hashtable，具有默认的初始容量(11)和加载系数(0.75)。
 public Hashtable() {
        this(11, 0.75f);
    }
    
 //构造一个指定初始容量的新的Hashtable，具有默认的加载系数(0.75)。
 public Hashtable(int initialCapacity) {
        this(initialCapacity, 0.75f);
    }
    
 //构造一个指定初始容量和指定加载系数的新的Hashtable。
 public Hashtable(int initialCapacity, float loadFactor) {
        if (initialCapacity &amp;lt; 0)
            throw new IllegalArgumentException(&quot;Illegal Capacity: &quot;+
                                               initialCapacity);
        if (loadFactor &amp;lt;= 0 || Float.isNaN(loadFactor))
            throw new IllegalArgumentException(&quot;Illegal Load: &quot;+loadFactor);

        if (initialCapacity==0)
            initialCapacity = 1;
        this.loadFactor = loadFactor;
        table = new HashtableEntry&amp;lt;?,?&amp;gt;[initialCapacity];
        threshold = (int)Math.min(initialCapacity, MAX_ARRAY_SIZE + 1);
    }

 //根据传入的Map一个新的HashTable。HashTable的初始容量足以容纳给定Map中的映射数据，并具有默认的加载因子(0.75)。
 public Hashtable(Map&amp;lt;? extends K, ? extends V&amp;gt; t) {
        this(Math.max(2*t.size(), 11), 0.75f);
        putAll(t);
    }
     
 public synchronized void putAll(Map&amp;lt;? extends K, ? extends V&amp;gt; t) {
        for (Map.Entry&amp;lt;? extends K, ? extends V&amp;gt; e : t.entrySet())
            put(e.getKey(), e.getValue());
    }
    
 //添加键值对，是一个同步的方法
 public synchronized V put(K key, V value) {
        //禁止添加空的value
        if (value == null) {
            throw new NullPointerException();
        }

        HashtableEntry&amp;lt;?,?&amp;gt; tab[] = table;
        int hash = key.hashCode();
        //根据key的hash值和表容量计算下标
        //0x7FFFFFFF是一个用16进制表示的整型,是整型里面的最大值
        //转成2进制由31个1组成，而整形的最高是32位
        //hash与其按位与得到一个正数
        int index = (hash &amp;amp; 0x7FFFFFFF) % tab.length;
        @SuppressWarnings(&quot;unchecked&quot;)
        //获得对应下标的单链表
        HashtableEntry&amp;lt;K,V&amp;gt; entry = (HashtableEntry&amp;lt;K,V&amp;gt;)tab[index];
        //如果存在key值相同的键值对，则替换value
        for(; entry != null ; entry = entry.next) {
            if ((entry.hash == hash) &amp;amp;&amp;amp; entry.key.equals(key)) {
                V old = entry.value;
                entry.value = value;
                return old;
            }
        }
        
        addEntry(hash, key, value, index);
        return null;
    }
    
private void addEntry(int hash, K key, V value, int index) {
        modCount++;

        HashtableEntry&amp;lt;?,?&amp;gt; tab[] = table;
        //判断当前容量是否超出或等于扩容阈值
        if (count &amp;gt;= threshold) {
            // 如果超过阈值，则扩容
            rehash();
            
            //扩容后重新计算下标index
            tab = table;
            hash = key.hashCode();
            index = (hash &amp;amp; 0x7FFFFFFF) % tab.length;
        }

        //创建新的HashtableEntry，并赋值
        @SuppressWarnings(&quot;unchecked&quot;)
        HashtableEntry&amp;lt;K,V&amp;gt; e = (HashtableEntry&amp;lt;K,V&amp;gt;) tab[index];
        tab[index] = new HashtableEntry&amp;lt;&amp;gt;(hash, key, value, e);
        //数据量+1
        count++;
    }
    
  //扩容，并对内部的键值对重新排列
  protected void rehash() {
        int oldCapacity = table.length;
        HashtableEntry&amp;lt;?,?&amp;gt;[] oldMap = table;

        //新容量为两倍旧容量+1
        int newCapacity = (oldCapacity &amp;lt;&amp;lt; 1) + 1;
        //判断新容量是否超出最大容量
        if (newCapacity - MAX_ARRAY_SIZE &amp;gt; 0) {
            if (oldCapacity == MAX_ARRAY_SIZE)
                // Keep running with MAX_ARRAY_SIZE buckets
                return;
            newCapacity = MAX_ARRAY_SIZE;
        }
        //使用新容量创建一个新的数组table
        HashtableEntry&amp;lt;?,?&amp;gt;[] newMap = new HashtableEntry&amp;lt;?,?&amp;gt;[newCapacity];

        modCount++;
        //计算新的扩容阈值
        threshold = (int)Math.min(newCapacity * loadFactor, MAX_ARRAY_SIZE + 1);
        table = newMap;
        
        //将旧map数组的数据导入新map数组,重新计算下标
        for (int i = oldCapacity ; i-- &amp;gt; 0 ;) {
            for (HashtableEntry&amp;lt;K,V&amp;gt; old = (HashtableEntry&amp;lt;K,V&amp;gt;)oldMap[i] ; old != null ; ) {
                HashtableEntry&amp;lt;K,V&amp;gt; e = old;
                old = old.next;

                int index = (e.hash &amp;amp; 0x7FFFFFFF) % newCapacity;
                e.next = (HashtableEntry&amp;lt;K,V&amp;gt;)newMap[index];
                newMap[index] = e;
            }
        }
    }
    
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;可以看出其实&lt;strong&gt;HashTable&lt;/strong&gt;与&lt;strong&gt;HashMap&lt;/strong&gt;的初始化类似，在初始化时是不会初始化我们的数据表&lt;strong&gt;table&lt;/strong&gt;，只会初始化一些容量大小和负载因子的值，在第一次使用时才会创建。例如&lt;strong&gt;putAll&lt;/strong&gt;。&lt;/p&gt;
&lt;h4 id=&quot;putkv-1&quot;&gt;put(K,V)&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;put(K,V)&lt;/strong&gt;:推入指定的键值对的映射。如果该映射先前包含了该键的映射，则旧值将被替换。&lt;strong&gt;key&lt;/strong&gt;和&lt;strong&gt;value&lt;/strong&gt;都不能为null。&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt; public synchronized V put(K key, V value) {
        //确保valu不为null
        if (value == null) {
            throw new NullPointerException();
        }

        HashtableEntry&amp;lt;?,?&amp;gt; tab[] = table;
        //计算下标
        int hash = key.hashCode();
        int index = (hash &amp;amp; 0x7FFFFFFF) % tab.length;
        @SuppressWarnings(&quot;unchecked&quot;)
        //获得对应下标的单链表
        HashtableEntry&amp;lt;K,V&amp;gt; entry = (HashtableEntry&amp;lt;K,V&amp;gt;)tab[index];
        //如果存在在key值已存在，则替换value
        for(; entry != null ; entry = entry.next) {
            if ((entry.hash == hash) &amp;amp;&amp;amp; entry.key.equals(key)) {
                V old = entry.value;
                entry.value = value;
                return old;
            }
        }
        //不存在添加键值对
        addEntry(hash, key, value, index);
        return null;
    }
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;h4 id=&quot;removeobject-1&quot;&gt;remove(Object)&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;remove(Object)&lt;/strong&gt;:从这个&lt;strong&gt;HashTable&lt;/strong&gt;移除&lt;strong&gt;key&lt;/strong&gt;(及其对应的&lt;strong&gt;value&lt;/strong&gt;)。如果&lt;strong&gt;key&lt;/strong&gt;不在&lt;strong&gt;HashTable&lt;/strong&gt;中，此方法不执行任何操作。&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt; public synchronized V remove(Object key) {
        //计算下标
        HashtableEntry&amp;lt;?,?&amp;gt; tab[] = table;
        int hash = key.hashCode();
        int index = (hash &amp;amp; 0x7FFFFFFF) % tab.length;
        
        @SuppressWarnings(&quot;unchecked&quot;)
        HashtableEntry&amp;lt;K,V&amp;gt; e = (HashtableEntry&amp;lt;K,V&amp;gt;)tab[index];
        //判断是否存在对应的key值
        for(HashtableEntry&amp;lt;K,V&amp;gt; prev = null ; e != null ; prev = e, e = e.next) {
            if ((e.hash == hash) &amp;amp;&amp;amp; e.key.equals(key)) {
                modCount++;
                if (prev != null) {
                    prev.next = e.next;
                } else {
                    tab[index] = e.next;
                }
                count--;
                V oldValue = e.value;
                e.value = null;
                return oldValue;
            }
        }
        return null;
    }

&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;h4 id=&quot;getobject-1&quot;&gt;get(Object)&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;get(Object)&lt;/strong&gt;:返回指定&lt;strong&gt;key&lt;/strong&gt;对应的&lt;strong&gt;value&lt;/strong&gt;,若&lt;strong&gt;key&lt;/strong&gt;不在&lt;strong&gt;HashTable&lt;/strong&gt;中，则返回&lt;strong&gt;null&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
10
11
12
13
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt; public synchronized V get(Object key) {
        //计算下标
        HashtableEntry&amp;lt;?,?&amp;gt; tab[] = table;
        int hash = key.hashCode();
        int index = (hash &amp;amp; 0x7FFFFFFF) % tab.length;
        //找key对应的value
        for (HashtableEntry&amp;lt;?,?&amp;gt; e = tab[index] ; e != null ; e = e.next) {
            if ((e.hash == hash) &amp;amp;&amp;amp; e.key.equals(key)) {
                return (V)e.value;
            }
        }
        return null;
    }
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;h4 id=&quot;clear-1&quot;&gt;clear()&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;clear()&lt;/strong&gt;:清空此&lt;strong&gt;HashTable&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;  public synchronized void clear() {
        HashtableEntry&amp;lt;?,?&amp;gt; tab[] = table;
        modCount++;
        for (int index = tab.length; --index &amp;gt;= 0; )
            tab[index] = null;
        count = 0;
    }
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;HashTable&lt;/strong&gt;的方法基本都是&lt;strong&gt;synchronized&lt;/strong&gt;的，相对于&lt;strong&gt;HashMap&lt;/strong&gt;是同步的。&lt;/p&gt;
&lt;h2 id=&quot;hashmap与hashtable的不同&quot;&gt;HashMap与HashTable的不同&lt;/h2&gt;
&lt;h3 id=&quot;一-线程安全性&quot;&gt;一 线程安全性&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;HashTable&lt;/strong&gt;方法添加了&lt;strong&gt;synchronized&lt;/strong&gt;关键字，是同步的，是线程安全的&lt;/li&gt;
  &lt;li&gt;
    &lt;ul&gt;
      &lt;li&gt;&lt;strong&gt;HashMap&lt;/strong&gt;是非同步的，线程不安全&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;二-内部方法&quot;&gt;二 内部方法&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;Hashtable&lt;/strong&gt;则保留了&lt;strong&gt;contains&lt;/strong&gt;，&lt;strong&gt;containsValue&lt;/strong&gt;和&lt;strong&gt;containsKey&lt;/strong&gt;三个方法，其中&lt;strong&gt;contains&lt;/strong&gt;和&lt;strong&gt;containsValue&lt;/strong&gt;功能相同。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;HashMap&lt;/strong&gt;没有&lt;strong&gt;contains&lt;/strong&gt;方法去掉了，改成&lt;strong&gt;containsValue&lt;/strong&gt;和&lt;strong&gt;containsKey&lt;/strong&gt;，因为&lt;strong&gt;contains&lt;/strong&gt;方法容易让人引起误解。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;方法内容对比：
&lt;strong&gt;HashTable&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;  
  public synchronized boolean contains(Object value) {
        //value不能为null
        if (value == null) {
            throw new NullPointerException();
        }
        //包含返回true,不包含返回false
        HashtableEntry&amp;lt;?,?&amp;gt; tab[] = table;
        for (int i = tab.length ; i-- &amp;gt; 0 ;) {
            for (HashtableEntry&amp;lt;?,?&amp;gt; e = tab[i] ; e != null ; e = e.next) {
                if (e.value.equals(value)) {
                    return true;
                }
            }
        }
        return false;
    }
  //查看是否包含value
  public boolean containsValue(Object value) {
        return contains(value);
    }
    
  //查看是否包含key
  public synchronized boolean containsKey(Object key) {
        HashtableEntry&amp;lt;?,?&amp;gt; tab[] = table;
        int hash = key.hashCode();
        int index = (hash &amp;amp; 0x7FFFFFFF) % tab.length;
        for (HashtableEntry&amp;lt;?,?&amp;gt; e = tab[index] ; e != null ; e = e.next) {
             //包含返回true,不包含返回false
            if ((e.hash == hash) &amp;amp;&amp;amp; e.key.equals(key)) {
                return true;
            }
        }
        return false;
    }
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;HashMap&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt; public boolean containsValue(Object value) {
        Node&amp;lt;K,V&amp;gt;[] tab; V v;
        if ((tab = table) != null &amp;amp;&amp;amp; size &amp;gt; 0) {
            for (int i = 0; i &amp;lt; tab.length; ++i) {
                for (Node&amp;lt;K,V&amp;gt; e = tab[i]; e != null; e = e.next) {
                    if ((v = e.value) == value ||
                        (value != null &amp;amp;&amp;amp; value.equals(v)))
                        return true;
                }
            }
        }
        return false;
    }

  public boolean containsKey(Object key) {
        return getNode(hash(key), key) != null;
    }
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;h3 id=&quot;key和value的限制&quot;&gt;key和value的限制&lt;/h3&gt;
&lt;p&gt;根据上面的&lt;strong&gt;containsValue&lt;/strong&gt;和&lt;strong&gt;containsKey&lt;/strong&gt;方法得出：
&lt;strong&gt;Hashtable&lt;/strong&gt;:&lt;strong&gt;key&lt;/strong&gt;和&lt;strong&gt;value&lt;/strong&gt;都不允许出现&lt;strong&gt;null&lt;/strong&gt;值；
&lt;strong&gt;HashMap&lt;/strong&gt;:&lt;strong&gt;null&lt;/strong&gt;可以作为&lt;strong&gt;key&lt;/strong&gt;，这样的&lt;strong&gt;key&lt;/strong&gt;只有一个；但是可以有一个或多个&lt;strong&gt;key&lt;/strong&gt;所对应的值为&lt;strong&gt;null&lt;/strong&gt;。当&lt;strong&gt;get()&lt;/strong&gt;方法返回n&lt;strong&gt;ull&lt;/strong&gt;值时，可能是 &lt;strong&gt;HashMap&lt;/strong&gt;中没有该键，也可能使该键所对应的值为&lt;strong&gt;null&lt;/strong&gt;。因此，在&lt;strong&gt;HashMap&lt;/strong&gt;中不能由&lt;strong&gt;get()&lt;/strong&gt;方法来判断&lt;strong&gt;HashMap&lt;/strong&gt;中是否存在某个&lt;strong&gt;key&lt;/strong&gt;， 而应该用&lt;strong&gt;containsKey()&lt;/strong&gt;方法来判断。&lt;/p&gt;
&lt;h3 id=&quot;两个遍历方式的内部实现上不同&quot;&gt;两个遍历方式的内部实现上不同&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;Hashtable&lt;/strong&gt;:使用了 &lt;strong&gt;Iterator&lt;/strong&gt;
&lt;strong&gt;HashMap&lt;/strong&gt;:使用了 &lt;strong&gt;Iterator&lt;/strong&gt;。由于历史原因，还使用了&lt;strong&gt;Enumeration&lt;/strong&gt;的方式 。&lt;/p&gt;
&lt;h3 id=&quot;hash值不同&quot;&gt;hash值不同&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;Hashtable&lt;/strong&gt;:直接使用对象的&lt;strong&gt;hashCode&lt;/strong&gt;,&lt;strong&gt;hashCode&lt;/strong&gt;是jdk根据对象的地址或者字符串或者数字算出来的&lt;strong&gt;int&lt;/strong&gt;类型的数值。&lt;strong&gt;Hashtable&lt;/strong&gt;在求&lt;strong&gt;hash&lt;/strong&gt;值对应的位置索引时，用取模运算;
&lt;strong&gt;HashMap&lt;/strong&gt;:重新计算&lt;strong&gt;hash&lt;/strong&gt;值,在求位置索引时，则用与运算;&lt;/p&gt;

&lt;h3 id=&quot;内部实现使用的数组初始化和扩容方式不同&quot;&gt;内部实现使用的数组初始化和扩容方式不同&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;Hashtable&lt;/strong&gt;:在不指定容量的情况下的默认容量为11,&lt;strong&gt;Hashtable&lt;/strong&gt;不要求底层数组的容量一定要为2的整数次幂;扩容时，&lt;strong&gt;Hashtable&lt;/strong&gt;将容量变为原来的2倍加1
&lt;strong&gt;HashMap&lt;/strong&gt;:在不指定容量的情况下的默认容量为16,&lt;strong&gt;HashMap&lt;/strong&gt;要求底层数组的容量一定为2的整数次幂,扩容时，&lt;strong&gt;HashMap&lt;/strong&gt;将容量变为原来的2倍。&lt;/p&gt;

&lt;h2 id=&quot;treemap&quot;&gt;TreeMap&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;TreeMap&lt;/strong&gt;是一个非同步有序的&lt;strong&gt;key-value&lt;/strong&gt;集合，它通过&lt;strong&gt;红黑树&lt;/strong&gt;实现，实现了&lt;strong&gt;NavigableMap&lt;/strong&gt;接口，意味着它支持一系列的导航方法。比如返回&lt;strong&gt;有序的key集合&lt;/strong&gt;。该映射根据其键的自然顺序进行排序，或者根据创建映射时提供的 &lt;strong&gt;Comparator&lt;/strong&gt; 进行排序，具体取决于使用的构造方法。
&lt;strong&gt;TreeMap&lt;/strong&gt;的基本操作 &lt;strong&gt;containsKey&lt;/strong&gt;、&lt;strong&gt;get&lt;/strong&gt;、&lt;strong&gt;put&lt;/strong&gt; 和 &lt;strong&gt;remove&lt;/strong&gt; 的时间复杂度是 &lt;strong&gt;log(n)&lt;/strong&gt; 。使用不多，就暂不介绍了。&lt;/p&gt;
</description>
        <pubDate>Sun, 20 Dec 2020 19:50:02 +0800</pubDate>
        <link>https://yuhanchen5027.github.io//article/2020/12/20/JAVA%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%86%85%E9%83%A8%E5%8F%8A%E5%9F%BA%E7%A1%80%E6%96%B9%E6%B3%95%E5%AE%9E%E7%8E%B0%E4%B8%80-Map/</link>
        <guid isPermaLink="true">https://yuhanchen5027.github.io//article/2020/12/20/JAVA%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%86%85%E9%83%A8%E5%8F%8A%E5%9F%BA%E7%A1%80%E6%96%B9%E6%B3%95%E5%AE%9E%E7%8E%B0%E4%B8%80-Map/</guid>
        
        <category>JAVA</category>
        
        <category>数据结构</category>
        
        
        <category>article</category>
        
      </item>
    
      <item>
        <title>JAVA数据结构简单概括</title>
        <description>&lt;h1 id=&quot;java数据结构&quot;&gt;JAVA数据结构&lt;/h1&gt;
&lt;h3 id=&quot;map&quot;&gt;Map&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;Map&lt;/strong&gt;接口提供key到value的映射。一个Map中不能包含相同的key，每个key只能映射一个value。&lt;/p&gt;
&lt;h4 id=&quot;hashmap&quot;&gt;HashMap&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;HashMap&lt;/strong&gt;继承&lt;strong&gt;Map&lt;/strong&gt;接口，由数组+单链表或者数组+红黑树实现一个key-value映射的哈希表。是非同步的，同时允许nul
danll value和null key。&lt;/p&gt;

&lt;h4 id=&quot;hashtable&quot;&gt;HashTable&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;Hashtable&lt;/strong&gt;与&lt;strong&gt;HashMap&lt;/strong&gt;哈希冲突少的时候一样都是数组+单链表，任何非空（non-null）的对象都可作为key或者value，其方法都带有&lt;strong&gt;synchronized&lt;/strong&gt;关键字，是线程同步的。&lt;/p&gt;
&lt;h4 id=&quot;hashmap与hashtable的不同&quot;&gt;HashMap与HashTable的不同&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;HashTable&lt;/strong&gt;线程安全， &lt;strong&gt;HashMap&lt;/strong&gt;线程不安全；&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;HashMap&lt;/strong&gt;删除了&lt;strong&gt;contains&lt;/strong&gt;方法；&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;HashMap&lt;/strong&gt;key-value允许为null;&lt;strong&gt;HashTable&lt;/strong&gt;不允许。
    &lt;h4 id=&quot;treemap&quot;&gt;TreeMap&lt;/h4&gt;
    &lt;p&gt;&lt;strong&gt;TreeMap&lt;/strong&gt;是一个非同步&lt;strong&gt;有序&lt;/strong&gt;的key-value集合，它通过红黑树实现,可以返回&lt;strong&gt;有序的key集合&lt;/strong&gt;。&lt;/p&gt;
    &lt;h2 id=&quot;collection&quot;&gt;Collection&lt;/h2&gt;
    &lt;p&gt;&lt;strong&gt;Collection&lt;/strong&gt;是最基本的集合接口，一个&lt;strong&gt;Collection&lt;/strong&gt;代表一组&lt;strong&gt;Object&lt;/strong&gt;，&lt;strong&gt;Collection&lt;/strong&gt;支持一个&lt;strong&gt;iterator()&lt;/strong&gt;的方法，该方法返回一个迭代子，使用该迭代子即可逐一访问&lt;strong&gt;Collection&lt;/strong&gt;中每一个元素。&lt;/p&gt;
    &lt;h3 id=&quot;list&quot;&gt;List&lt;/h3&gt;
    &lt;p&gt;&lt;strong&gt;List&lt;/strong&gt;是有序的&lt;strong&gt;Collection&lt;/strong&gt;，用户能够使用索引来访问&lt;strong&gt;List&lt;/strong&gt;中的元素，允许有相同的元素。&lt;/p&gt;
    &lt;h4 id=&quot;linkedlist&quot;&gt;LinkedList&lt;/h4&gt;
    &lt;p&gt;&lt;strong&gt;双向链表&lt;/strong&gt;结构，适用于乱序插入、删除。获取数据时首先判断是在前半部分还是后半部分，之后分别通过队首/队尾来向后、向前遍历获取对应的数据。&lt;/p&gt;
    &lt;h4 id=&quot;arraylist&quot;&gt;ArrayList&lt;/h4&gt;
    &lt;p&gt;&lt;strong&gt;ArrayList&lt;/strong&gt;是动态数组，底层就是一个数组, 因此按序查找快, 乱序插入, 删除因为涉及到后面元素移位所以性能慢。&lt;/p&gt;
    &lt;h4 id=&quot;vector&quot;&gt;Vector&lt;/h4&gt;
    &lt;p&gt;&lt;strong&gt;Vector&lt;/strong&gt;是矢量队列，与&lt;strong&gt;ArrayList&lt;/strong&gt;不同，&lt;strong&gt;Vector&lt;/strong&gt;中的操作是线程安全的。&lt;/p&gt;
    &lt;h4 id=&quot;stack&quot;&gt;Stack&lt;/h4&gt;
    &lt;p&gt;&lt;strong&gt;Stack&lt;/strong&gt;继承自&lt;strong&gt;Vector&lt;/strong&gt;，实现一个后进先出的堆栈。&lt;strong&gt;Stack&lt;/strong&gt;提供5个额外的方法使得&lt;strong&gt;Vector&lt;/strong&gt;得以被当作堆栈使用。基本的&lt;strong&gt;push&lt;/strong&gt;和&lt;strong&gt;pop&lt;/strong&gt;方法，还有&lt;strong&gt;peek&lt;/strong&gt;方法得到栈顶的元素，&lt;strong&gt;empty&lt;/strong&gt;方法测试堆栈是否为空，&lt;strong&gt;search&lt;/strong&gt;方法检测一个元素在堆栈中的位置。&lt;strong&gt;Stack&lt;/strong&gt;刚创建后是空栈。&lt;/p&gt;
    &lt;h3 id=&quot;set&quot;&gt;Set&lt;/h3&gt;
    &lt;p&gt;&lt;strong&gt;Set&lt;/strong&gt;是一种不包含重复的元素的&lt;strong&gt;Collection&lt;/strong&gt;，即任意的两个元素e1和e2都有e1.equals(e2)=false，Set最多有一个null元素。&lt;/p&gt;
    &lt;h4 id=&quot;hashset&quot;&gt;HashSet&lt;/h4&gt;
    &lt;p&gt;&lt;strong&gt;HashSet&lt;/strong&gt;这个类实现了&lt;strong&gt;Set&lt;/strong&gt;集合，实际内部是使用&lt;strong&gt;HashMap&lt;/strong&gt;的实例。内部使用&lt;strong&gt;HashMap&lt;/strong&gt;存储时用key的位置来存储，value的地方存储一个没有内容的&lt;strong&gt;Object&lt;/strong&gt;实例，所以可以保证没有重复的元素。&lt;em&gt;HashSet&lt;/em&gt;是线程不同步的;&lt;/p&gt;
    &lt;h4 id=&quot;treeset&quot;&gt;TreeSet&lt;/h4&gt;
    &lt;p&gt;&lt;strong&gt;TreeSet&lt;/strong&gt;是一个有序的集合，它的作用是提供有序的Set集合。&lt;strong&gt;TreeSet&lt;/strong&gt;的元素支持2种排序方式：自然排序或者根据提供的&lt;strong&gt;Comparator&lt;/strong&gt;进行排序。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Sun, 29 Nov 2020 19:30:00 +0800</pubDate>
        <link>https://yuhanchen5027.github.io//article/2020/11/29/JAVA%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AE%80%E5%8D%95%E6%A6%82%E6%8B%AC/</link>
        <guid isPermaLink="true">https://yuhanchen5027.github.io//article/2020/11/29/JAVA%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AE%80%E5%8D%95%E6%A6%82%E6%8B%AC/</guid>
        
        <category>JAVA</category>
        
        <category>数据结构</category>
        
        
        <category>article</category>
        
      </item>
    
      <item>
        <title>Android 系统中新增广播提供给应用设置静态ip</title>
        <description>&lt;h1 id=&quot;系统中新增静态ip设置&quot;&gt;系统中新增静态ip设置&lt;/h1&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;本文主要目的是开发提供给应用开发使用修改连接Wifi或以太网时的静态ip设置，采用广播的方式控制，在Setting是内同实现时仿照Settings应用内部的修改方式实现。  
新增两个广播：  
1.com.cyh.wifi_static_ip：wifi静态ip设置广播
2.com.cyh.eth_static_ip：以太网静态ip设置广播
在Settings内新增一个广播接收NetworkStaticReceiver.java ## AndroidManifest.xml  在**AndroidManifest.xml**文件内添加上我们新增的**NetworkStaticReceiver**和相关广播 ```
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;receiver android:name=&quot;NetworkStaticReceiver&quot;&gt;
            &lt;intent-filter android:priority=&quot;1000&quot;&gt;
                &lt;action android:name=&quot;com.cyh.wifi_static_ip&quot; /&gt;
                &lt;action android:name=&quot;com.cyh.eth_static_ip&quot; /&gt;
            &lt;/intent-filter&gt;
       &lt;/receiver&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;之后来看**NetworkStaticReceiver.java**文件的内容
## NetworkStaticReceiver.java
路径：packages/apps/Settings/src/com/android/settings/NetworkStaticReceiver.java，只发逻辑部分，省略了import部分。
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;public class NetworkStaticReceiver extends BroadcastReceiver{
     private final String WIFI_STATIC_IP = “com.cyh.wifi_static_ip”;
     private final String ETH_STATIC_IP = “com.cyh.eth_static_ip”;
     private final String TAG=”NetworkStaticReceiver”;&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
82
83
84
85
86
87
88
89
90
91
92
93
94
95
96
97
98
99
100
101
102
103
104
105
106
107
108
109
110
111
112
113
114
115
116
117
118
119
120
121
122
123
124
125
126
127
128
129
130
131
132
133
134
135
136
137
138
139
140
141
142
143
144
145
146
147
148
149
150
151
152
153
154
155
156
157
158
159
160
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt; @Override
    public void onReceive(Context context, Intent intent){
            String action = intent.getAction();
            switch(action){
                if(WIFI_STATIC_IP.equals(action)){
            //Wi-Fi静态设置
             //获得是否设置为静态模式
                    boolean isStatic =  intent.getBooleanExtra(&quot;Static&quot;,false);
                    //获取连接wifi的config
                    WifiManager mWifiManager = (WifiManager)context.getApplicationContext().getSystemService(Context.WIFI_SERVICE);
                    WifiConfiguration config = new WifiConfiguration();
                    WifiInfo connectionInfo= mWifiManager.getConnectionInfo();
                            List&amp;lt;WifiConfiguration&amp;gt; configuredNetworks=mWifiManager.getConfiguredNetworks();
                            for (WifiConfiguration conf : configuredNetworks) {
                                    if (conf.networkId==connectionInfo.getNetworkId()) {
                                            config=conf;
                                            break;
                                    }
                            }
                    if(isStatic){
                             //获得设置的Wi-Fi静态ip，网关，DNS1，DNS2
                            String ip = intent.getStringExtra(&quot;staticIp&quot;);
                            String gateway = intent.getStringExtra(&quot;gateway&quot;);
                            String dns1 = intent.getStringExtra(&quot;dns1&quot;);
                            String dns2 = intent.getStringExtra(&quot;dns2&quot;);
                            //判断传入参数是否为空，空的话给默认值
                            ip = ip ==null?&quot;192.168.0.123&quot;:ip;
                            gateway = gateway ==null?&quot;192.168.1.1&quot;:gateway;
                            dns1 = dns1 ==null?&quot;8.8.8.8&quot;:dns1;
                            dns2 = dns2 ==null?&quot;8.8.4,4&quot;:dns2;
                            //validateIpConfigFields用于验证ip，网管，dns1，dns2，并将相关设置项转换成StaticIpConfiguration
                            StaticIpConfiguration mStaticIpConfiguration = validateIpConfigFields(ip,gateway,dns1,dns2);
                           
                           if(mStaticIpConfiguration == null){
                                    //设置相关内容有问题时mStaticIpConfiguration会为null
                                    return;
                            }
                            config.setStaticIpConfiguration(mStaticIpConfiguration);
                            mWifiManager.updateNetwork(config);
                            boolean saveConfiguration = mWifiManager.saveConfiguration();

                            int netId = mWifiManager.addNetwork(config);
                            //断开网络
                            mWifiManager.disableNetwork(netId);
                            //重新连接
                            mWifiManager.enableNetwork(netId, true);
                    }else{
                            //动态IP模式（DHCP）
                            config.setIpAssignment(IpAssignment.DHCP);
                            mWifiManager.updateNetwork(config);
                            mWifiManager.saveConfiguration();
                            int netId = mWifiManager.addNetwork(config);
                            //断开网络
                            mWifiManager.disableNetwork(netId);
                            //重新连接
                            mWifiManager.enableNetwork(netId, true);
                    }
            } else if(ETH_STATIC_IP.equals(action)){
                    //获得是否设置为静态模式
                    boolean isStatic =  intent.getBooleanExtra(&quot;Static&quot;,false);
                    Log.i(TAG,&quot;ETH_STATIC_IP isStatic:&quot;+isStatic);
                    EthernetManager mEthManager = (EthernetManager)context.getApplicationContext().getSystemService(Context.ETHERNET_SERVICE);
                    if(isStatic){
                            String ip = intent.getStringExtra(&quot;staticIp&quot;);
                            String gateway = intent.getStringExtra(&quot;gateway&quot;);
                            String dns1 = intent.getStringExtra(&quot;dns1&quot;);
                            String dns2 = intent.getStringExtra(&quot;dns2&quot;);
                            //判断传入参数是否为空，空的话给默认值
                            ip = ip ==null?&quot;192.168.0.123&quot;:ip;
                            gateway = gateway ==null?&quot;192.168.1.1&quot;:gateway;
                            dns1 = dns1 ==null?&quot;8.8.8.8&quot;:dns1;
                            dns2 = dns2 ==null?&quot;8.8.4,4&quot;:dns2;
                            StaticIpConfiguration mStaticIpConfiguration = validateIpConfigFields(ip,gateway,dns1,dns2);
                              if(mStaticIpConfiguration == null){
                                    //设置相关内容有问题时mStaticIpConfiguration会为null
                                    return;
                            }
                            IpConfiguration mIpConfiguration = new IpConfiguration(IpAssignment.STATIC, ProxySettings.NONE,mStaticIpConfiguration,null);
                            mEthManager.setConfiguration(mIpConfiguration);
                    }else{
                            //动态IP模式（DHCP）
                            mEthManager.setConfiguration(new IpConfiguration(IpAssignment.DHCP, ProxySettings.NONE,null,null));
                    }
            }
    }
}
//验证ip，网管，dns1，dns2，并将相关设置项转换成StaticIpConfiguration
public StaticIpConfiguration validateIpConfigFields(String ipAddr,String gateway,String dns1,String dns2){
    StaticIpConfiguration staticIpConfiguration = new StaticIpConfiguration();
     //ip地址
    if (TextUtils.isEmpty(ipAddr)){
            Log.i(TAG,&quot;Type a valid IP address.&quot;);
            return null;
    }
    Inet4Address inetAddr = getIPv4Address(ipAddr);
    if (inetAddr == null) {
        Log.i(TAG,&quot;Type a valid IP address.&quot;);
        return null;
    }
    
    int networkPrefixLength = -1;
    try {
        networkPrefixLength = 24;
        if (networkPrefixLength &amp;lt; 0 || networkPrefixLength &amp;gt; 32) {
            Log.i(TAG,&quot;Type a network prefix length between 0 and 32.&quot;);
            return null;
        }
        staticIpConfiguration.ipAddress = new LinkAddress(inetAddr, networkPrefixLength);
    } catch (NumberFormatException e) {
         Log.i(TAG,&quot;24&quot;);
    }
    //网关
    if (TextUtils.isEmpty(gateway)) {
        try {
            //Extract a default gateway from IP address
            InetAddress netPart = NetworkUtils.getNetworkPart(inetAddr, networkPrefixLength);
            byte[] addr = netPart.getAddress();
            addr[addr.length-1] = 1;
        } catch (RuntimeException ee) {
            }
    } else {
        InetAddress gatewayAddr = getIPv4Address(gateway);
        if (gatewayAddr == null) {
              Log.i(TAG,&quot;ype a valid gateway address.&quot;);
            return null;
        }
        staticIpConfiguration.gateway = gatewayAddr;
    }
    //dns1
    InetAddress dnsAddr = null;
    if (TextUtils.isEmpty(dns1)) {
         Log.i(TAG,&quot;8.8.8.8&quot;);
    } else {
        dnsAddr = getIPv4Address(dns1);
        if (dnsAddr == null) {
            Log.i(TAG,&quot;Type a valid DNS address.&quot;);
            return null;
        }
        staticIpConfiguration.dnsServers.add(dnsAddr);
    }
    
    //dns2
    if (!TextUtils.isEmpty(dns2)) {
        dnsAddr = getIPv4Address(dns2);
        if (dnsAddr == null) {
            Log.i(TAG,&quot;Type a valid DNS address.&quot;);
            return null;
        }
        staticIpConfiguration.dnsServers.add(dnsAddr);
    }
    return staticIpConfiguration;
}

private Inet4Address getIPv4Address(String text) {
    try {
        return (Inet4Address) NetworkUtils.numericToInetAddress(text);
    } catch (IllegalArgumentException|ClassCastException e) {
        return null;
    }
}
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;}&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;以上就是NetworkStaticReceiver.java的逻辑内容，大体逻辑步骤可简述为：  
接收广播-&amp;gt;辨别广播是WI-FI设置还是以太网设置  
1. WI-FI设置：
- 获得当前连接wifi的config，获得isStatic对应的值-&amp;gt;
- true则获取设置的ip，网关,dns等设置项的值,false则直接设置为DHCP-&amp;gt;   
- 判断设置信息是否正常，同时封装成**StaticIpConfiguration**-&amp;gt;
- 将**StaticIpConfiguration**设置进当前Wi-Fi-&amp;gt;
- 通过WifiManager更新并保存配置config-&amp;gt;
- 断开网络连接，之后重连（只有这样设置后才有效）。
2. 以太网设置
- 获得isStatic对应的值-&amp;gt;
- true则获取设置的ip，网关,dns等设置项的值,false则直接设置为DHCP-&amp;gt;
- 判断设置信息是否正常，同时封装成**StaticIpConfiguration**-&amp;gt;
- 创建一个**IpConfiguration**用来存放**StaticIpConfiguration**，同时设置为STATIC模式-&amp;gt;
- 通过**EthernetManager**保存配置项;

## 应用内控制方法
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;/**
     * 控制Wi-Fi的状态
     * @param isStatic true为STATIC模式，false为DNCP模式。只有TRUE时之后的配置项才有效，false时后面的参数设置null即可
     * @param staticIp STATIC模式下的静态ip
     * @param gateway  STATIC模式下的网关
     * @param dns1     STATIC模式下的dns
     * @param dns2     STATIC模式下的备用dns
     */
    public void controlWifiStatic(boolean isStatic,String staticIp,String gateway,String dns1,String dns2){
        Intent intent = new Intent(“com.cyh.wifi_static_ip”);
        intent.putExtra(“Static”,isStatic);
        intent.putExtra(“staticIp”,staticIp);
        intent.putExtra(“gateway”,gateway);
        intent.putExtra(“dns1”,dns1);
        intent.putExtra(“dns2”,dns2;
        sendBroadcast(intent);
    }&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;//调用示例
controlWifiStatic(true,&quot;192.168.0.190&quot;,&quot;192.168.0.1&quot;,&quot;8.8.8.8&quot;,&quot;8.8.4.4&quot;);
 
 /**
 * 控制以太网的状态
 * @param isStatic true为STATIC模式，false为DNCP模式。只有TRUE时之后的配置项才有效，false时后面的参数设置null即可
 * @param staticIp STATIC模式下的静态ip
 * @param gateway  STATIC模式下的网关
 * @param dns1     STATIC模式下的dns
 * @param dns2     STATIC模式下的备用dns
 */
public void controlEthStatic(boolean isStatic,String staticIp,String gateway,String dns1,String dns2){
    Intent intent = new Intent(&quot;com.cyh.eth_static_ip&quot;);
    intent.putExtra(&quot;Static&quot;,isStatic);
    intent.putExtra(&quot;staticIp&quot;,staticIp);
    intent.putExtra(&quot;gateway&quot;,gateway);
    intent.putExtra(&quot;dns1&quot;,dns1);
    intent.putExtra(&quot;dns2&quot;,dns2;
    sendBroadcast(intent);
}
 //调用示例
controlEthStatic(true,&quot;192.168.0.190&quot;,&quot;192.168.0.1&quot;,&quot;8.8.8.8&quot;,&quot;8.8.4.4&quot;); ```
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

</description>
        <pubDate>Mon, 09 Mar 2020 19:31:00 +0800</pubDate>
        <link>https://yuhanchen5027.github.io//article/2020/03/09/Android%E7%B3%BB%E7%BB%9F%E4%B8%AD%E6%96%B0%E5%A2%9E%E5%B9%BF%E6%92%AD%E6%8F%90%E4%BE%9B%E7%BB%99%E5%BA%94%E7%94%A8%E8%AE%BE%E7%BD%AE%E9%9D%99%E6%80%81ip/</link>
        <guid isPermaLink="true">https://yuhanchen5027.github.io//article/2020/03/09/Android%E7%B3%BB%E7%BB%9F%E4%B8%AD%E6%96%B0%E5%A2%9E%E5%B9%BF%E6%92%AD%E6%8F%90%E4%BE%9B%E7%BB%99%E5%BA%94%E7%94%A8%E8%AE%BE%E7%BD%AE%E9%9D%99%E6%80%81ip/</guid>
        
        <category>Android</category>
        
        <category>Framework</category>
        
        
        <category>article</category>
        
      </item>
    
      <item>
        <title>Android进程和线程间通信方式</title>
        <description>&lt;h1 id=&quot;android进程和线程间通信方式&quot;&gt;Android进程和线程间通信方式&lt;/h1&gt;
&lt;p&gt;进程：是具有一定独立功能的程序关于某个数据集合上的一次运行活动，进程是系统进行资源分配和调度的一个独立单位。&lt;/p&gt;

&lt;p&gt;线程：是进程的一个实体,是CPU调度和分派的基本单位,它是比进程更小的能独立运行的基本单位。线程自己基本上不拥有系统资源,只拥有一些在运行中必不可少的资源(如程序计数器,一组寄存器和栈)，但是它可与同属一个进程的其他的线程共享进程所拥有的全部资源。&lt;/p&gt;

&lt;p&gt;区别：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;（1）、一个程序至少有一个进程，一个进程至少有一个线程；&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;（2）、线程的划分尺度小于进程，使得多线程程序的并发性高；&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;（3）、进程在执行过程中拥有独立的内存单元，而多个线程共享内存，但线程之间没有单独的地址空间，一个线程死掉就等于整个进程死掉。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;android进程间通信方式&quot;&gt;Android进程间通信方式&lt;/h2&gt;
&lt;p&gt;可分为七种&lt;/p&gt;
&lt;h3 id=&quot;1bundle&quot;&gt;1、Bundle&lt;/h3&gt;
&lt;p&gt;由于Activity,Service,Receiver都是可以通过Intent来携带Bundle传输数据的，所以我们可以在一个进程中通过&lt;strong&gt;Intent&lt;/strong&gt;将携带数据的&lt;strong&gt;Bundle&lt;/strong&gt;发送到另一个进程的组件。
由于&lt;strong&gt;Bundle&lt;/strong&gt;实现了&lt;strong&gt;Parcelable&lt;/strong&gt;接口，所以他可以方便地在不同进程间传递。
缺点：无法传输Bundle不支持的类型，即传输的数据必须能够序列化（如&lt;strong&gt;基本类型&lt;/strong&gt;，实现了&lt;strong&gt;Parcelable&lt;/strong&gt;或者&lt;strong&gt;Serializable&lt;/strong&gt;接口的对象以及一些Aandroid支持的对象）；&lt;/p&gt;

&lt;h3 id=&quot;2文件共享&quot;&gt;2、文件共享&lt;/h3&gt;
&lt;p&gt;两个进程通过读/写同一个文件来交换数据，由于Android系统基于Linux，所以其并发读/写文件可以没有限制的进行，除了可以通过文件交换一些文本信息外，还可以序列化一个对象到文件系统中的同时从另一个进程恢复这个对象。
文件共享适合在对数据同步要求不高的进程之间进行通信，并且要妥善处理并发读/写问题
缺点：不适合&lt;strong&gt;并发读/写&lt;/strong&gt;；&lt;/p&gt;

&lt;p&gt;当然 &lt;strong&gt;SharedPreference&lt;/strong&gt;是个特例，&lt;strong&gt;SharedPreference&lt;/strong&gt;是Android中提供的轻量级存储方案，通过键值对的方式存储数据，在底层上实现上采用&lt;strong&gt;XML&lt;/strong&gt;文件来存储键值对，每个应用的&lt;strong&gt;SharePreference&lt;/strong&gt;文件都在当前包所在的data目录下查看到，&lt;strong&gt;/data/package name/shared_prefs&lt;/strong&gt;目录下。
&lt;strong&gt;SharedPreference&lt;/strong&gt;也属于文件的一种，但是由于系统对他的读/写有一定的缓存策略，即在内存中会有一份&lt;strong&gt;SharedPreference&lt;/strong&gt;文件的缓存你，因此在多进程模式下，系统对它的的读/写就变的不可靠，当面对高并发的读/写访问，SharedPreferences有很大几率会丢失数据，因此，不建议在进程间通信中使用&lt;strong&gt;SharedPreference&lt;/strong&gt;。&lt;/p&gt;

&lt;h3 id=&quot;3messenger&quot;&gt;3、Messenger&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;Messenger&lt;/strong&gt;可翻译为心事，通过它可以在不同进程中传递&lt;strong&gt;Message&lt;/strong&gt;对象，&lt;strong&gt;Messenger&lt;/strong&gt;是一种轻量级的IPC方案，基于AIDL实现，服务端（被动方）提供一个Service来处理客户端（主动方）连接，维护一个&lt;strong&gt;Handler&lt;/strong&gt;来创建&lt;strong&gt;Messenger&lt;/strong&gt;，在&lt;strong&gt;onBind&lt;/strong&gt;时返回&lt;strong&gt;Messenger&lt;/strong&gt;的&lt;strong&gt;binder&lt;/strong&gt;。双方用&lt;strong&gt;Messenger&lt;/strong&gt;来发送数据，用&lt;strong&gt;Handler&lt;/strong&gt;来处理数据。&lt;strong&gt;Messenger&lt;/strong&gt;处理数据依靠&lt;strong&gt;Handler&lt;/strong&gt;，所以是&lt;strong&gt;串行&lt;/strong&gt;的，也就是说，&lt;strong&gt;Handler&lt;/strong&gt;接到多个&lt;strong&gt;message&lt;/strong&gt;时，就要&lt;strong&gt;排队依次处理&lt;/strong&gt;。如果有大量的并发请求，使用&lt;strong&gt;Messenger&lt;/strong&gt;就不太合适了。
使用方式如下：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;在服务端进程创建一个&lt;strong&gt;Service&lt;/strong&gt;来处理客户端的连接请求，同时创建一个&lt;strong&gt;Handler&lt;/strong&gt;并通过创建一个&lt;strong&gt;Messenger&lt;/strong&gt;对象，然后再Service的&lt;strong&gt;onBind&lt;/strong&gt;中返回这个&lt;strong&gt;Messenger&lt;/strong&gt;对象给底层的Binder即可；&lt;/li&gt;
  &lt;li&gt;在客户端进程绑定服务端的&lt;strong&gt;Service&lt;/strong&gt;，绑定成功后用服务端返回的&lt;strong&gt;IBinder&lt;/strong&gt;对象创建一个&lt;strong&gt;Messenger&lt;/strong&gt;，通过这个&lt;strong&gt;Messenger&lt;/strong&gt;就可以向服务端发送消息了，发消息类型为&lt;strong&gt;Message&lt;/strong&gt;对象，如果需要服务端能够回应客户端，还需创建一个&lt;strong&gt;Handler&lt;/strong&gt;并创建一个新的&lt;strong&gt;Messenger&lt;/strong&gt;。并把这个&lt;strong&gt;Messenger&lt;/strong&gt;对象通过&lt;strong&gt;Message&lt;/strong&gt;的&lt;strong&gt;replyTo&lt;/strong&gt;参数传递给服务端。服务端通过这个&lt;strong&gt;replyTo&lt;/strong&gt;参数就可以回应客户端。&lt;/li&gt;
  &lt;li&gt;在&lt;strong&gt;Messenger&lt;/strong&gt;中进行数据传递必须将数据放入&lt;strong&gt;Message&lt;/strong&gt;中，而&lt;strong&gt;Messenger&lt;/strong&gt;和&lt;strong&gt;Message&lt;/strong&gt;都实现了&lt;strong&gt;Parcelable&lt;/strong&gt;接口，因此可以跨进程传输。同时，&lt;strong&gt;Message&lt;/strong&gt;所支持的数据类型就是&lt;strong&gt;Messenger&lt;/strong&gt;所支持的传输类型。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;4contentprovider&quot;&gt;4、ContentProvider&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;ContentProvider&lt;/strong&gt;是Android四大组件之一，换门用于不同应用间进行数据共享，以表格的方式存储数据，底层实现基于&lt;strong&gt;Binder&lt;/strong&gt;，由于系统的封装，&lt;strong&gt;ContentProvider&lt;/strong&gt;使用比AIDL简单。系统预置了许多&lt;strong&gt;ContentProvider&lt;/strong&gt;（例如通讯录信息，日程表，信息等）。
&lt;strong&gt;ContentProvider&lt;/strong&gt;的使用方法：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;继承&lt;strong&gt;ContentProvider&lt;/strong&gt;，并实现六个抽象方法：&lt;/li&gt;
  &lt;li&gt;
    &lt;ul&gt;
      &lt;li&gt;1、onCreate：代表&lt;strong&gt;ContentProvider&lt;/strong&gt;的创建，一般做些初始化工作；&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;ul&gt;
      &lt;li&gt;2、insert：增；&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;ul&gt;
      &lt;li&gt;3、delete：删&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;ul&gt;
      &lt;li&gt;4、update：改；&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;ul&gt;
      &lt;li&gt;5、query：查；&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;ul&gt;
      &lt;li&gt;6、getType：用来返回一个Uri请求所对应的&lt;strong&gt;MIME&lt;/strong&gt;类型（如媒体类型），比如图片，视频等，可直接返回null或”&lt;em&gt;/&lt;/em&gt;“（若不关注这个选项的话）。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;onCreate由系统回调运行在主线程，其他五个方法由外界回调并运行在&lt;strong&gt;Binder&lt;/strong&gt;线程池中。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;ContentProvider&lt;/strong&gt;主要以表格的形式来组织数据，并且可以包含多个表，对于每个表来说都具有行和列的层次性，行往往对应一条记录，列对应一条记录中的一个字段，这点和数据库类似。除了表哥形式，&lt;strong&gt;ContentProvider&lt;/strong&gt;还支持文件数据，比如图片、视频等。&lt;/p&gt;

&lt;h3 id=&quot;5broadcast&quot;&gt;5、Broadcast&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;Broadcast&lt;/strong&gt;可以向Android系统中所有应用程序发送广播，而需要跨进程通讯的应用程序可以监听这些广播。&lt;/p&gt;

&lt;h3 id=&quot;6socket&quot;&gt;6、Socket&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;Socket&lt;/strong&gt;是网络通信的概念，分为&lt;strong&gt;流式Socket&lt;/strong&gt;和&lt;strong&gt;用户数据报Socket&lt;/strong&gt;两种，分别对应网络的传输控制层种的TCP和UDP协议。&lt;strong&gt;Socket&lt;/strong&gt;本身可以支持传输任意字节流。&lt;strong&gt;Socket&lt;/strong&gt;通过网络进行数据交换，需要在子线程请求，不然会阻塞主线程，客户端和服务端建立连接之后即可不断传输数据，比较适合实时的数据传输。使用时在远程Service建立一个TCP服务，在主界面连接TCP服务，连接成功后向服务端发送消息。&lt;/p&gt;

&lt;h3 id=&quot;7aidl&quot;&gt;7、AIDL&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;AIDL&lt;/strong&gt;进行进程间通信的流程，分为服务端和客户端两个方面&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;1、服务端&lt;br /&gt;
   创建一个&lt;strong&gt;Service&lt;/strong&gt;用来监听客户端的连接请求，之后创建一个AIDL文件（通过AIDL文件会生成一个java文件，内部包含Stub和Stub.Proxy）将暴露给客户端的接口在AIDL声明，最后在&lt;strong&gt;Service&lt;/strong&gt;中实现&lt;strong&gt;Stub&lt;/strong&gt;即实现&lt;strong&gt;AIDL&lt;/strong&gt;接口即可；&lt;/li&gt;
  &lt;li&gt;2、客户端&lt;br /&gt;
   首先绑定服务端的Service，绑定成功后，将服务端返回的&lt;strong&gt;Binder&lt;/strong&gt;对象转成AIDL接口所属的类型，接着就可以调用&lt;strong&gt;AIDL&lt;/strong&gt;方法了&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;AIDL文件支持的数据类型：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;1、基本数据类型（int、long、char、boolean、double等）；&lt;/li&gt;
  &lt;li&gt;2、String和CharSequence；&lt;/li&gt;
  &lt;li&gt;3、List：只支持ArrayList，里面每个元素都必须能够被&lt;strong&gt;AIDL&lt;/strong&gt;支持；&lt;/li&gt;
  &lt;li&gt;4、Map：只支持HashMap，里面的每个元素都必须被&lt;strong&gt;AIDL&lt;/strong&gt;支持，包括Key和Value；&lt;/li&gt;
  &lt;li&gt;5、Parcelable：所有实现了Parcelable接口的对象；&lt;/li&gt;
  &lt;li&gt;6、AIDL：所有的ALDI接口本身也可以在AIDL文件中使用，如果AIDL文件中用到了自定义的&lt;strong&gt;Parcelable&lt;/strong&gt;对象，必须新创建一个和它同名的AIDL文件，并在其中声明它为&lt;strong&gt;Parcelable&lt;/strong&gt;类型。&lt;br /&gt;
AIDL除了基本数据类型，其他类型的参数必须标上方向；&lt;/li&gt;
  &lt;li&gt;in:输入型参数；&lt;/li&gt;
  &lt;li&gt;out：输出型参数；&lt;/li&gt;
  &lt;li&gt;inout：输入输出型参数；
例： void addBook(int Book book);
不能一致使用inout，这在底层是有开销的。&lt;br /&gt;
AIDL接口中支持方法，不支持声明的静态常量，这一点有别于传统接口。&lt;br /&gt;
建议将AIDL相关的类和文件全部放在同一个包中，好处是当客户端是另一个应用是，可以将整个包复制到客户端工程中。AIDL的包结构在服务端和客户端要保持一致。&lt;br /&gt;
如果要在服务端和客户端建立监听，需使用&lt;strong&gt;RemoteCallbackList&lt;/strong&gt;,因为正常传入的接口对象会在服务端重新转化成一个新的对象，解注册的时候对应不上。&lt;br /&gt;
&lt;strong&gt;RemoteCallbackList&lt;/strong&gt;是系统专门提供的用于删除跨进程listener的接口，它的内部有一个Map结构，专门用来保存所有的AIDL回调，Map的key是&lt;strong&gt;IBinder&lt;/strong&gt;类型，value是&lt;strong&gt;Callback&lt;/strong&gt;类型。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;使用示例：&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
10
11
12
13
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;private RemouteCallbackList&amp;lt;ITestListener&amp;gt; = mListenerList = 
    new RemoteCallbackList&amp;lt;ItestListener&amp;gt;();
    
//注册
mListenerList.register(listener);
//解注册
mListenerList.unregister(listener);
//遍历
final int N = mListenerList.beginBroadcast();
for(int i=0;i&amp;lt;N;i++){
    mListenerList.getBroadcastItem(i).xxx();
}
mListenerList.finishBroadcast();
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;ul&gt;
  &lt;li&gt;客户端调用远程服务的方法，被调用的方法运行在服务端的&lt;strong&gt;Binder线程池&lt;/strong&gt;中，同时客户端会被挂起，这时如果服务端执行比较耗时，就会导致客户端线程阻塞。不可再UI线程调用服务端耗时方法。需要把调用放在非UI线程。同样，当服务端调用客户端的listener中的方法是，被调用的方法运行在客户端的&lt;strong&gt;Binder线程池&lt;/strong&gt;，所以同样不可以在服务端中调用客户端耗时方法。若要调用，保证运行在非UI线程，否则将导致服务端无法响应。&lt;/li&gt;
  &lt;li&gt;由于客户端的listener运行在客户端的&lt;strong&gt;Binder线程池&lt;/strong&gt;，所以不能在它里面访问UI相关的内容，如果要访问UI，需要使用Handler切换到UI线程。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Binder可能会意外停止，往往是由于服务端进程意外停止了，这时需要重连服务，有两种方式：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;1、给Binder设置&lt;strong&gt;DeathRecipient&lt;/strong&gt;监听，当Binder死亡时，会收到BinderDied方法的回调
    &lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
10
11
12
13
14
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;private IBinder.DeathRecipient mDeathRecipient = 
      new IBinder.DeatgRecipient(){
          @Overwide
          public void binderDied(){
              if(mTestManager == null){
                  return;
              }
              mTestManager.asBinder().unlinkToDeath(mDeathRecipient);
              mTestMnager = null;
              //这次重新绑定远程Service
              ...
          }
            
      }
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
    &lt;p&gt;在客户端绑定远程服务后，给Binder设置死亡代理&lt;/p&gt;
    &lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;mService = ITestManager.Stub.asInterface(binder);
binder.linkToDeath(mDeathRecipient,0);
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;2、在onServiceDisconnected中重连远程服务&lt;br /&gt;
区别在于onServiceDisconnected在客户端的UI线程被回调，而binderDied在客户端的Binder线程池中回调；&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;在AIDL中加入&lt;strong&gt;权限验证&lt;/strong&gt;功能&lt;br /&gt;
有两种常用方法：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;1、在onBind中进行验证，验证不通过直接返回null,这样验证失败的客户端无法绑定服务。验证方法有很多种，比如使用&lt;strong&gt;premission&lt;/strong&gt;验证：首先在AndroidManifest中声明所需权限：
```&lt;/li&gt;
&lt;/ul&gt;
&lt;permission android:name=&quot;com.cyh.test.ACCESS_SERVICE&quot; android:procetionLevel=&quot;normal&quot; /&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;内部的应用绑定到我们的服务同样在AndroidManifest中加入
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;user-permission android:name=&quot;com.cyh.test.ACCESS_SERVICE&quot; /&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;之后在Service类中
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;TestManagerService.onBind:
public IBinder onBind(Intent intent){
    int check = checkCallingOrSelfPermission(“com.cyh.test.ACCESS_SERVICE”);
    if(check == PackageManager.PERMISSION_DENIED){
        return null;
    }
    return mBinder;
}&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;- 2、可以在服务端的onTransact方法中进行验证，验证失败则直接返回false，这样服务端会中指进行AIDL中的方法，从而达到保护服务器的效果。验证方法同样有很多，可以采用与1类型的permission验证。还可以采用Uid和Pid验证，通过**getCallingUid**和**getCallingPid**可以拿到客户端所属应用的**Pid**和**Uid**，通过这两个参数可以做一些验证工作,比如验证包名：
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;//包名验证如下：
String packageName = null;
String[] packages = getPackageManger().getPackagesForUid(getCallingUid());
if(packages!=null&amp;amp;&amp;amp; packages.length&amp;gt;0){
    packageName = packages[0];
}
if(!packageName.startWith(com.cyh)){
    return false;
}
return super.onTransact(code,data,reply,flags);
```&lt;/p&gt;

</description>
        <pubDate>Mon, 02 Mar 2020 11:46:20 +0800</pubDate>
        <link>https://yuhanchen5027.github.io//article/2020/03/02/Android%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1%E6%96%B9%E5%BC%8F/</link>
        <guid isPermaLink="true">https://yuhanchen5027.github.io//article/2020/03/02/Android%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1%E6%96%B9%E5%BC%8F/</guid>
        
        <category>Android</category>
        
        <category>进程与线程</category>
        
        
        <category>article</category>
        
      </item>
    
      <item>
        <title>Android 应用安装添加密码输入弹窗</title>
        <description>&lt;p&gt;基于RK Android6.0-MID代码
packages/apps/PackageInstaller/src/com/android/packageinstaller/PackageInstallerActivity.java
为防止之后遗忘，记录一下
安装apk时会弹出输入弹窗，输入内容正确，才可以点击安装按钮，输入错误安装应用弹窗消失&lt;/p&gt;

&lt;p&gt;先引用需要用到的类&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;import android.widget.EditText;
import android.app.AlertDialog;
import android.view.Display;
import android.view.WindowManager;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;在startInstallConfirm方法内添加如下代码&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;//cyh add start
          try {
                String packageName = mPkgInfo.packageName;     
                final EditText et = new EditText(PackageInstallerActivity.this);
                AlertDialog.Builder builder = new AlertDialog.Builder(PackageInstallerActivity.this);
                builder.setTitle(&quot;请输入安装应用密码&quot;)
                .setIcon(android.R.drawable.sym_def_app_icon)
                .setView(et)
                .setPositiveButton(&quot;确定&quot;, new DialogInterface.OnClickListener() {
                    @Override
                    public void onClick(DialogInterface dialogInterface, int i) {
                         if (et.getText().toString().equals(&quot;12345678&quot;)) {
                            //按下确定键后的事件
                            android.widget.Toast.makeText(PackageInstallerActivity.this, &quot;密码正确&quot;, android.widget.Toast.LENGTH_LONG).show();
                        } else {
                            android.widget.Toast.makeText(PackageInstallerActivity.this,&quot;密码错误&quot;, android.widget.Toast.LENGTH_LONG).show();
                            finish();
                            return;
                        }
                    }
                }).setNegativeButton(&quot;取消&quot;, new DialogInterface.OnClickListener() {
                    @Override
                    public void onClick(DialogInterface dialogInterface, int i) {
                         finish();
              		 return;
                    }
                });
                final AlertDialog dialog = builder.create();
                //获取屏幕的长宽
                WindowManager window=getWindowManager();
                Display display=window.getDefaultDisplay();
                int screenheight=display.getHeight();
                int screenWidth=display.getWidth();
                dialog.setCancelable(false);
                dialog.show();
                //设置弹出框的长宽
                dialog.getWindow().setLayout(screenWidth/3,screenheight/4);
           }catch(NullPointerException e){
                   e.printStackTrace();
           }
        //cyh add end 
        TabHost tabHost = (TabHost)findViewById(android.R.id.tabhost);
        tabHost.setup();
        ........
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
</description>
        <pubDate>Fri, 21 Sep 2018 11:07:20 +0800</pubDate>
        <link>https://yuhanchen5027.github.io//article/2018/09/21/Android-%E5%BA%94%E7%94%A8%E5%AE%89%E8%A3%85%E6%B7%BB%E5%8A%A0%E5%AF%86%E7%A0%81%E8%BE%93%E5%85%A5%E5%BC%B9%E7%AA%97/</link>
        <guid isPermaLink="true">https://yuhanchen5027.github.io//article/2018/09/21/Android-%E5%BA%94%E7%94%A8%E5%AE%89%E8%A3%85%E6%B7%BB%E5%8A%A0%E5%AF%86%E7%A0%81%E8%BE%93%E5%85%A5%E5%BC%B9%E7%AA%97/</guid>
        
        <category>Android</category>
        
        <category>Framework</category>
        
        
        <category>article</category>
        
      </item>
    
      <item>
        <title>Android 设置标志位限制应用安装</title>
        <description>&lt;p&gt;只有标志位为1的时候的apk才可以安装，否则apk都不能安装
需要修改的文件有以下几个
/frameworks/base/core/java/android/provider/Settings.java
/frameworks/base/packages/SettingsProvider/src/com/android/providers/settings/DatabaseHelper.java
/frameworks/base/packages/SettingsProvider/res/values/defaults.xml
/frameworks/base/services/core/java/com/android/server/pm/PackageManagerService.java
/frameworks/base/core/java/android/content/pm/PackageManager.java&lt;/p&gt;

&lt;h2 id=&quot;1-settingsjava&quot;&gt;1 Settings.java&lt;/h2&gt;
&lt;p&gt;数据分类
SettingsProvider对数据进行了分类，分别是Global、System、Secure三种类型，它们的区别如下：&lt;/p&gt;

&lt;p&gt;Global：所有的偏好设置对系统的所有用户公开，第三方APP有读没有写的权限；
System：包含各种各样的用户偏好系统设置；
Secure：安全性的用户偏好系统设置，第三方APP有读没有写的权限。
参考文章：https://blog.csdn.net/myfriend0/article/details/59107989
我们这次添加在Global中，要添加另外两个类中方法也是类似的
首先我们在Settings的内部类Global中加入我们用来限制应用安装的标志位&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;/**
* cyh add 
* app install lock
* @hide
*/
public static final String APP_INSTALL_LOCK = &quot;app_install_lock&quot;;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;之后在SETTINGS_TO_BACKUP字符串数组中加入这个标志位&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;public static final String[] SETTINGS_TO_BACKUP = {
...
...
APP_INSTALL_LOCK
};

&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;h2 id=&quot;2-databasehelperjava&quot;&gt;2 DatabaseHelper.java&lt;/h2&gt;
&lt;p&gt;设定标志位初始值
在
/frameworks/base/packages/SettingsProvider/res/values/defaults.xml
资源文件内加入默认值&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;...
&amp;lt;!-- cyh add app install lock --&amp;gt;
&amp;lt;bool name=&quot;def_app_install_lock&quot;&amp;gt;true&amp;lt;/bool&amp;gt;
...
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;在DatabaseHelper的loadGlobalSettings()方法内（System类型就在loadSystemSettings()方法内）加入初始值设置&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;...
//cyh add start
//设定默认值
loadBooleanSetting(stmt, Settings.Global.APP_INSTALL_LOCK,
R.bool.def_app_install_lock);
//cyh add end 
...
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;h2 id=&quot;3-packagemanagerservicejava&quot;&gt;3 PackageManagerService.java&lt;/h2&gt;
&lt;p&gt;在scanPackageLI方法下加入如下代码
一定要将NullPointerException抛出，在标志位数据库未生成时会运行到这个方法内，若不抛出异常，则会卡在android开机画面&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;boolean success = false;
//cyh add start
//获取应用安装锁
if(mContext!=null&amp;amp;&amp;amp;mContext.getContentResolver()!=null){
try {
int  appInstallLock = android.provider.Settings.Global.getInt(mContext.getContentResolver(),android.provider.Settings.Global.APP_INSTALL_LOCK , 1);
if (appInstallLock==0){
int mLastScanError = PackageManager.INSTALL_FAILED_INVALID_LOCK;
throw new PackageManagerException(mLastScanError,
&quot;禁止安装，安装模式未开启动&quot;);
}
}catch(NullPointerException e){
//一定要将NullPointerException抛出，在标志位数据库未生成时会运行到这个方法内，若不抛出异常，则会卡在android开机画面
e.printStackTrace();
}
}
//cyh add end 
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;h2 id=&quot;4-packagemanagerjava&quot;&gt;4 PackageManager.java&lt;/h2&gt;
&lt;p&gt;加入错误标志，其实影响不大，看你要不要在自己的应用内做判断&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;/**
* cyh add
* app install failed lock noopen
* cyh end 
* @hide
*/
public static final int INSTALL_FAILED_INVALID_LOCK = -27;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;使用方式：
在自己的应用内加入权限&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&amp;lt;!-- 用于读取，修改标志位--&amp;gt;
&amp;lt;uses-permission android:name=&quot;android.permission.READ_EXTERNAL_STORAGE&quot; /&amp;gt;
&amp;lt;uses-permission android:name=&quot;android.permission.WRITE_SETTINGS&quot; /&amp;gt;
&amp;lt;uses-permission android:name=&quot;android.permission.WRITE_SECURE_SETTINGS&quot; /&amp;gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;在方法中&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
10
11
12
13
14
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;private final String APP_INSTALL_LOCK = &quot;app_install_lock&quot;;
...
//方法内
//读取标志位的值
int keyValue;
try {
int keyValue = Settings.Global.getInt(getContentResolver(),APP_INSTALL_LOCK);
} catch (Settings.SettingNotFoundException e) {
e.printStackTrace();
}
//修改标志位的值
Settings.Global.putInt(getContentResolver(),APP_INSTALL_LOCK,value==0? 
1:0);
...
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
</description>
        <pubDate>Wed, 06 Jun 2018 12:01:20 +0800</pubDate>
        <link>https://yuhanchen5027.github.io//article/2018/06/06/Android-%E8%AE%BE%E7%BD%AE%E6%A0%87%E5%BF%97%E4%BD%8D%E9%99%90%E5%88%B6%E5%BA%94%E7%94%A8%E5%AE%89%E8%A3%85/</link>
        <guid isPermaLink="true">https://yuhanchen5027.github.io//article/2018/06/06/Android-%E8%AE%BE%E7%BD%AE%E6%A0%87%E5%BF%97%E4%BD%8D%E9%99%90%E5%88%B6%E5%BA%94%E7%94%A8%E5%AE%89%E8%A3%85/</guid>
        
        <category>Android</category>
        
        <category>Framework</category>
        
        
        <category>article</category>
        
      </item>
    
      <item>
        <title>Android 根据已装应用的签名限制其他应用安装</title>
        <description>&lt;p&gt;参考文章：https://blog.csdn.net/loongembedded/article/details/54090873
只有使用特定签名签的apk才可以安装，其他任何apk都不能安装&lt;/p&gt;

&lt;p&gt;最好是应用预装一个使用对应签名的应用&lt;/p&gt;

&lt;p&gt;需要修改的文件有以下几个
/frameworks/base/services/core/java/com/android/server/pm/PackageManagerService.java&lt;/p&gt;

&lt;p&gt;/frameworks/base/core/java/android/content/pmPackageManager.java&lt;/p&gt;

&lt;p&gt;/packages/apps/PackageInstaller/src/com/android/packageinstaller/InstallAppProgress.java&lt;/p&gt;

&lt;p&gt;/packages/apps/PackageInstaller/res/values/string.xml&lt;/p&gt;

&lt;h2 id=&quot;1-packagemanagerservicejava&quot;&gt;1 PackageManagerService.java&lt;/h2&gt;
&lt;p&gt;/frameworks/base/services/core/java/com/android/server/pm/PackageManagerService.java
添加getSignaturesByPackage()方法&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;//add start
private Signature[] getSignaturesByPackage(){
Signature[] signatures = null;
//已签名的已安装应用包名，与该应用签名不同的应用无法安装
String packageName = &quot;com.xxxx.xxxxx&quot;;
PackageSetting ps = mSettings.mPackages.get(packageName);
if (ps != null) {
PackageParser.Package pkg = ps.pkg;
if (pkg == null) {
pkg = new PackageParser.Package(packageName);
pkg.applicationInfo.packageName = packageName;
pkg.applicationInfo.flags = ps.pkgFlags | ApplicationInfo.FLAG_IS_DATA_ONLY;
pkg.applicationInfo.publicSourceDir = ps.resourcePathString;
pkg.applicationInfo.sourceDir = ps.codePathString;
pkg.applicationInfo.dataDir = getDataPathForPackage(packageName, 0).getPath();
// pkg.applicationInfo.nativeLibraryDir = ps.nativeLibraryPathString;
}

PackageInfo packageInfo2 = generatePackageInfo(pkg, PackageManager.GET_SIGNATURES, UserHandle.getCallingUserId());

if(packageInfo2 != null){
signatures = packageInfo2.signatures;
}
}
mIsInstallApkFlag = false;
return signatures;
}
//add end
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;在scanPackageLI方法下加入如下代码&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
10
11
12
13
14
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;private PackageParser.Package scanPackageLI(PackageParser.Package pkg, int parseFlags , int scanFlags, long currentTime, UserHandle user) throws PackageManagerException {
boolean success = false;
//add start  
//获得安装的应用的签名信息
Signature[] originalSignatures = getSignaturesByPackage();
if (originalSignatures != null) {
if (compareSignatures(originalSignatures, pkg.mSignatures) != PackageManager.SIGNATURE_MATCH) {
int mLastScanError = PackageManager.INSTALL_FAILED_INVALID_SIGNATURES;
throw new PackageManagerException(mLastScanError,
&quot;禁止安装，签名不符&quot;);
}
}
//add end
...
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;同时要import缺少的类。&lt;/p&gt;
&lt;h2 id=&quot;2-packagemanagerjava&quot;&gt;2 PackageManager.java&lt;/h2&gt;
&lt;p&gt;/frameworks/base/core/java/android/content/pm/PackageManager.java
加入错误代码 INSTALL_FAILED_INVALID_SIGNATURES&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;/** 
* Installation return code: this is passed to the {@link IPackageInstallObserver} by 
* {@link #installPackage(android.net.Uri, IPackageInstallObserver, int)} if 
* the installed package hasn't the expected signature 
*  @hide 
*/
public static final int INSTALL_FAILED_INVALID_SIGNATURES = -26;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;h2 id=&quot;3-installappprogressjava&quot;&gt;3 InstallAppProgress.java&lt;/h2&gt;
&lt;p&gt;/packages/apps/PackageInstaller/src/com/android/packageinstaller/InstallAppProgress.java
加入针对添加的错误代码的处理&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;private Handler mHandler = new Handler() {  
public void handleMessage(Message msg) {  
switch (msg.what) {  
...
//add start
} else if (msg.arg1 ==  PackageManager.INSTALL_FAILED_INVALID_SIGNATURES){
// Generic error handling for all other error codes.  
centerTextDrawable.setLevel(1);
centerExplanationLabel = getExplanationFromErrorCode(msg.arg1);
//centerTextLabel = R.string.install_failed_invalid_signature;  
centerTextLabel = R.string.install_failed_invalid_signature;
mLaunchButton.setVisibility(View.INVISIBLE);
//add end
}  else {
// Generic error handling for all other error codes.
centerTextDrawable.setLevel(1);
centerExplanationLabel = getExplanationFromErrorCode(msg.arg1);
centerTextLabel = R.string.install_failed;
mLaunchButton.setVisibility(View.INVISIBLE);
}
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;h2 id=&quot;4-stringsxml&quot;&gt;4 strings.xml&lt;/h2&gt;
&lt;p&gt;/packages/apps/PackageInstaller/res/values/string.xml
添加错误信息install_failed_invalid_signature&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&amp;lt;string name=&quot;install_failed_invalid_signature&quot;&amp;gt;禁止安装，签名不符&amp;lt;/string&amp;gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

</description>
        <pubDate>Thu, 26 Apr 2018 16:41:42 +0800</pubDate>
        <link>https://yuhanchen5027.github.io//article/2018/04/26/Android-%E6%A0%B9%E6%8D%AE%E5%B7%B2%E8%A3%85%E5%BA%94%E7%94%A8%E7%9A%84%E7%AD%BE%E5%90%8D%E9%99%90%E5%88%B6%E5%85%B6%E4%BB%96%E5%BA%94%E7%94%A8%E5%AE%89%E8%A3%85/</link>
        <guid isPermaLink="true">https://yuhanchen5027.github.io//article/2018/04/26/Android-%E6%A0%B9%E6%8D%AE%E5%B7%B2%E8%A3%85%E5%BA%94%E7%94%A8%E7%9A%84%E7%AD%BE%E5%90%8D%E9%99%90%E5%88%B6%E5%85%B6%E4%BB%96%E5%BA%94%E7%94%A8%E5%AE%89%E8%A3%85/</guid>
        
        <category>Android</category>
        
        <category>Framework</category>
        
        
        <category>article</category>
        
      </item>
    
      <item>
        <title>自封装的MediaPlayer 结合 SurfaceView 和 TextureView 的播放视频控件</title>
        <description>&lt;p&gt;自封装的MediaPlayer 结合 SurfaceView 和 TextureView 的播放视频控件
调用方法：
xml文件内添加&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&amp;lt;com.example.mvideoview.MyVideoView
android:id=&quot;@+id/videoview&quot;
android:layout_width=&quot;match_parent&quot;
android:layout_height=&quot;match_parent&quot; /&amp;gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;或者&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&amp;lt;com.example.mvideoview.MyTextureVideoView
android:id=&quot;@+id/videoview&quot;
android:layout_width=&quot;match_parent&quot;
android:layout_height=&quot;match_parent&quot; /&amp;gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;在界面内设置&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;//播放路径
String url = &quot;&quot;;
myVideoView = findViewById(R.id.videoview);
myVideoView.setmOnProgressListener(new IMediaPlayer.OnProgressListener() {
@Override
public void onSurfaceCreated() {
//设置播放路径
myVideoView.setVideoURL(url);
}

@Override
public void onPreparedListener(IMediaPlayer mediaPlayer) {
//开始播放
mediaPlayer.start();
}

@Override
public void onTotleProgressListener(int totalProgress) {
//拿到总进度值，可以在这里设置seekbar的Max值
}

@Override
public void onPlayProgress(int progress) {
//进度播放回调，一秒一次
}

@Override
public void onCompletion() {
//播放完成时
}
});
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;码云地址：[https://gitee.com/5027/VideoView] (https://gitee.com/5027/VideoView)&lt;/p&gt;

</description>
        <pubDate>Tue, 28 Nov 2017 15:40:10 +0800</pubDate>
        <link>https://yuhanchen5027.github.io//article/2017/11/28/%E8%87%AA%E5%B0%81%E8%A3%85MeidaPlayer+SurfaceView-%E5%92%8C-TextureView%E8%A7%86%E9%A2%91%E6%92%AD%E6%94%BE%E6%8E%A7%E4%BB%B6/</link>
        <guid isPermaLink="true">https://yuhanchen5027.github.io//article/2017/11/28/%E8%87%AA%E5%B0%81%E8%A3%85MeidaPlayer+SurfaceView-%E5%92%8C-TextureView%E8%A7%86%E9%A2%91%E6%92%AD%E6%94%BE%E6%8E%A7%E4%BB%B6/</guid>
        
        <category>MediaPlayer</category>
        
        <category>视频播放</category>
        
        
        <category>article</category>
        
      </item>
    
      <item>
        <title>Mac下搭建nginx http点播服务器</title>
        <description>&lt;h2 id=&quot;第一步-下载nginx和nginx_mod_h264_streaming-227&quot;&gt;第一步 下载nginx和nginx_mod_h264_streaming-2.2.7&lt;/h2&gt;
&lt;p&gt;nginx下载地址：http://nginx.org/en/download.html&lt;/p&gt;

&lt;p&gt;nginx_mod_h264_streaming-2.2.7 下载地址:
http://h264.code-shop.com/download/nginx_mod_h264_streaming-2.2.7.tar.gz&lt;/p&gt;

&lt;p&gt;解压nginx 和 nginx_mod_h264_streaming 到同一目录下&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/4273129-49feda242d8eafc2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;第二步-配置nginx&quot;&gt;第二步 配置nginx&lt;/h2&gt;
&lt;p&gt;进入文件夹nginx文件夹内，执行配置命令&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;cd nginx-1.13.5
./configure --add-module=../nginx_mod_h264_streaming-2.2.7 --with-http_flv_module --with-http_mp4_module
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;配置命令中 我们引入了第们刚才下载的三方模块nginx_mod_h264_streaming-2.2.7，以及nginx自带的mp4，flv模块&lt;/p&gt;

&lt;h2 id=&quot;第三步-编译安装nginx&quot;&gt;第三步 编译安装nginx&lt;/h2&gt;
&lt;h3 id=&quot;编译make&quot;&gt;编译make&lt;/h3&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;make
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;如果出现以下的错误，我们直接找到对应的文件进行修改：
####错误1:
&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/4273129-cf852fdfba918904.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;错误1&quot; /&gt;
我们进入”nginx_mod_h264_streaming-2.2.7/src/ “找到“ngx_http_streaming_module.c”文件并将zero_in_uri的方法注释或者删除&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/4273129-df482fc56491eab1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot; /&gt;
保存后再次make&lt;/p&gt;

&lt;h4 id=&quot;错误2&quot;&gt;错误2:&lt;/h4&gt;

&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/4273129-e21be49c01aedac2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;错误2&quot; /&gt;&lt;/p&gt;

&lt;p&gt;提示我们文件中有未使用的变量，未使用的那直接注释或者删除掉。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/4273129-2559f062cd07404a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;”nginx_mod_h264_streaming-2.2.7/src/ “找到“mp4_io.c”文件并将aac_channels的注释或者删除
&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/4273129-213c4db80df76ae9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot; /&gt;
保存后再次make
之后如果还有这种类型的错，采用同样的方基本都能解决了&lt;/p&gt;

&lt;h3 id=&quot;安装install&quot;&gt;安装install&lt;/h3&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;make install
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;此时可能出现”Permission denied” 权限问题
那我们就加上sudo命令再执行&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;sudo make install
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/4273129-3dd3b4e3f7333959.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot; /&gt;
我们可以看到安装目录是 “usr/local/nginx”&lt;/p&gt;

&lt;h3 id=&quot;第四步-配置nginxconf&quot;&gt;第四步 配置nginx.conf&lt;/h3&gt;
&lt;p&gt;nginx.conf文件在nginx目录下的conf文件夹下(即“usr/local/nginx/conf”)，
我们需要修改nginx.conf（直接修改需要权限，同样通过sudo命令开启vi编辑器进行修改）&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;cd /
cd usr/local/nginx/conf
sudo vi  nginx.conf
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;这里有许多相关的配置信息（要了解各种配置可以去看一下这个网页：http://www.cnblogs.com/hunttown/p/5759959.html），我们先不用管，直接进入http 的 server下修改为如下代码：&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;server {
listen       80;            #设置端口号
server_name  localhost;
root usr/local/nginx/;      #设置文件路径，默认也是nginx路径下

charset utf-8;              #设置编码

location /{                 #设置首页地址
root html;           #此处地址是usr/local/nginx/html
index index.html；   #对应打开的文件
}

location ~ \.mp4$ {
root movie;         #此处地址是usr/local/nginx/movie(电影就放在该文件夹下)
mp4;
}
location ~ \.flv {
root movie;
flv;
}
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;h3 id=&quot;第五步-启动nginx&quot;&gt;第五步 启动nginx&lt;/h3&gt;
&lt;p&gt;我们设定的视频读取路径是 “usr/local/nginx/movie”，将1.mp4视频文件放入该文件夹，启动nginx(nginx启动文件放在nginx下的sbin文件夹内)&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;cd /
cd usr/local/nginx/sbin
sudo ./nginx
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;此时在浏览器内输入 http://localhost:80/ 会显示如下界面(80为端口号，默认80不需要输入，如果修改了的话就要输入对应的端口号)：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/4273129-a89d30a00ff2b89f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;即代表开启成功，此时我们在浏览器内输入地址”http://localhost:80/1.mp4”即可以播放对应的视频了&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/4273129-888380bf0a3563f3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;nginx-启动关闭重启命令&quot;&gt;nginx 启动，关闭，重启命令&lt;/h3&gt;
&lt;p&gt;启动：./nginx
关闭：./nginx -s stop （快速停止nginx）
   ./nginx -s quit     (完整有序的停止nginx)
重启：./nginx -s reload （修改配置后重启）&lt;/p&gt;
</description>
        <pubDate>Sat, 30 Sep 2017 13:57:42 +0800</pubDate>
        <link>https://yuhanchen5027.github.io//article/2017/09/30/Mac%E4%B8%8B%E6%90%AD%E5%BB%BAnginx-http%E7%82%B9%E6%92%AD%E6%9C%8D%E5%8A%A1%E5%99%A8/</link>
        <guid isPermaLink="true">https://yuhanchen5027.github.io//article/2017/09/30/Mac%E4%B8%8B%E6%90%AD%E5%BB%BAnginx-http%E7%82%B9%E6%92%AD%E6%9C%8D%E5%8A%A1%E5%99%A8/</guid>
        
        <category>nginx</category>
        
        
        <category>article</category>
        
      </item>
    
  </channel>
</rss>
